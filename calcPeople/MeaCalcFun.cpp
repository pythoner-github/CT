#include <math.h>
#include <stdlib.h>
#include <string.h>
#include <errno.h>
#include <libavutil/time.h>
#include "Def.h"
#include "display/gui_func.h"
#include "calcPeople/MeaResult.h"
#include "calcPeople/MeaCalcFun.h"
#include <stdio.h>
#include "sysMan/SysGeneralSetting.h"
#include "sysMan/SysCalculateSetting.h"
#include "patient/PatientInfo.h"
#include "calcPeople/MenuCalcNew.h"

#define GW_TABLE_HEAD_LEN   3//产科表表头长度

int cer_custom[272]; //x10
int hl_custom[272]; //x10
int bpd_custom[272]; //x10
int fl_custom[272]; //x10
int crl_custom[272]; //x10
int gs_custom[272]; //x10
int ac_custom[272]; //x10
int hc_custom[272]; //x10
int tad_custom[272]; //x10
int apad_custom[272]; //x10
int thd_custom[272]; //x10
int ofd_custom[272]; //x10
int ood_custom[272]; //x10
int tibia_custom[272]; //x10
int ttd_custom[272]; //x10
int ulna_custom[272]; //x10
int fta_custom[272]; //x100

namespace {
const int HumanDOP = 280;//人的孕期长度280天
const int HumanDOP_Ovul = 266;  // 排卵期孕期长度280-14

/*
 * 产科表数组数据存储格式：前三个为表头长度－第一个元素为产科表数据长度，第二个为产科表数据相对于实际大小的倍数，第三个为表数据的起始时间。后面为产科表数据
 * */
//产科表的起始时间都还没加
const int cer_goldstein[] =
    {167, 10, 105, //15w0d-
    151, 152, 154, 155, 157, 159, 160, 161, 163, 164, 166, 167, 169,
    170, 171, 173, 174, 176, 177, 178, 180, 182, 185, 189, 191, 194, 197,
    199, 202, 202, 202, 202, 202, 202, 203, 204, 205, 208, 211, 213, 216,
    219, 221, 222, 224, 225, 227, 228, 230, 231, 232, 234, 236, 237, 239,
    241, 242, 245, 248, 251, 253, 256, 260, 262, 265, 268, 271, 273, 276,
    279, 281, 285, 288, 291, 293, 296, 299, 299, 299, 299, 299, 300, 301,
    302, 303, 307, 312, 315, 319, 324, 328, 330, 333, 334, 335, 337, 339,
    340, 342, 347, 351, 355, 359, 364, 368, 372, 375, 378, 380, 381, 386,
    389, 392, 395, 398, 400, 403, 406, 409, 412, 415, 418, 421, 423, 426,
    429, 433, 437, 442, 447, 450, 454, 458, 460, 462, 465, 467, 468, 470,
    472, 475, 478, 481, 483, 486, 489, 492, 495, 498, 501, 503, 507, 509,
    509, 509, 509, 509, 509, 509, 510, 511, 512, 514, 515, 517, 519, 521};

const int hl_jeanty[] = //12w2d-40w1d
    {196,  10, 86,
    90, 95, 99, 104, 108, 113, 117, 122, 126, 131, 135, 139, 143, 148, 152, 156, 160, 164, 168, 172, 176, 181, 185, 188,
    192, 196, 200, 204, 208, 212, 216 , 220, 223, 227, 231, 235, 238, 242, 246, 249, 253, 257, 260, 264, 267, 271, 274,
    278, 281, 285, 288, 292, 295, 299, 302, 305, 309, 312, 316, 319, 322, 326, 329, 332, 335, 339, 342, 345, 348, 352,
    355, 358, 361, 364, 368, 371, 374, 377, 380, 383, 386, 389, 392, 395, 398, 402, 405, 408, 411, 414, 417, 420, 422,
    425, 428, 431, 434, 437, 440, 443, 446, 449, 452, 455,  457, 460, 463, 466, 469, 472, 474, 477, 480, 483, 486, 488,
    491, 494, 497, 499, 502, 505, 507, 510, 513, 516, 518, 521, 524, 526, 529, 532, 534, 537, 539, 542, 545, 547, 550,
    553, 555, 558, 560, 563, 565, 568, 571, 573, 576, 578, 581, 583, 586, 588, 591, 593, 596, 598, 601, 603, 606, 608,
    611, 613, 616, 618, 620, 623, 625, 628, 630, 633, 635, 637, 640, 642, 645, 647, 649, 652, 654, 656, 659, 661, 664,
    666, 668, 671, 673, 675, 678, 680, 682, 684, 687, 689};

const int bpd_hadlock[] = //BPD*10  12w1d-42w1d
    {211, 10, 85,
    150,154,161,168,175,182,189,196,202,209,215,222,228,235,241,247,253,259,265,271,277,283,289,295,301,306,
    312,318,323,329,334,340,345,351,356,361,367,372,377,382,388,393,398,403,408,413,418,423,428,433,437,442,447,452,
    457,461,466,471,475,480,485,489,494,498,503,507,512,516,521,525,530,534,538,543,547,551,556,560,564,568,572,577,
    581,585,589,593,597,601,606,610,614,618,622,626,630,634,638,642,645,649,653,657,661,665,669,673,676,680,684,688,
    692,695,699,703,707,710,714,718,721,725,729,732,736,739,743,747,750,754,757,761,764,768,771,775,778,782,785,789,
    792,796,799,803,806,810,813,816,820,823,826,830,833,836,840,843,846,850,853,856,860,863,866,869,873,876,879,882,
    886,889,892,895,898,902,905,908,911,914,917,920,924,927,930,933,936,939,942,945,948,951,954,957,961,964,967,970,
    973,976,979,982,985,988,991,994,997,999,1002,1005,1008,1011,1014,1017,1020};

const int bpd_merz[] = //BPD    12w1d-40w2d 198
    {198, 1, 85,
    21,21,22,22,23,23,24,25,25,25,26,26,27,27,28,29,29,30,30,31,31,32,32,33,33,34,34,35,35,36,36,37,37,38,38,39,39,40,
    40,41,41,42,42,43,43,44,44,45,45,46,46,47,47,48,48,49,49,50,50,51,51,52,52,53,53,54,54,55,55,56,56,56,57,57,58,58,
    59,59,59,60,60,61,61,62,62,62,63,63,64,64,65,65,65,66,66,67,67,68,68,68,69,69,70,70,71,71,72,72,73,73,73,74,74,75,
    75,75,76,76,77,77,77,78,78,79,79,79,80,80,81,81,81,82,82,82,83,83,83,84,84,84,85,85,86,86,86,87,87,87,87,88,88,89,
    89,89,90,90,90,90,91,91,91,92,92,93,93,93,93,94,94,94,95,95,95,95,96,96,96,96,97,97,97,98,98,98,98,99,99,99,100,100,
    100,100,101,101,101,101,102,102};

const int bpd_lasser[] = //BPD*10   7w0d-14w0d
    {50, 10, 49,
    47,49,51,53,56,58,61,63,66,69,72,75,79,82,86,89,93,97,102,106,111,116,121,126,132,137,143,150,156,163,170,178,186,
    194,202,211,220,230,240,251,262,273,285,298,311,324,338,353,369,385};

const int bpd_rempen[] = //BPD 6w6d-13w5d
    {50, 1, 48,
    3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,
    25,25,26,26,27,27};

const int bpd_tokyo[]= //BPD*10 12w1d-37w2d   177 in total
    {177, 10, 85,
    201,203,208,214,218,222,225,229,234,239,243,248,253,259,264,268,273,279,293,295,
    297,300,304,308,315,318,324,328,333,339,344,348,353,359,363,369,372,376,380,385,388,393,
    401,403,409,413,419,423,429,434,438,442,446,450,456,460,463,468,473,478,483,488,493,498,
    502,505,509,514,519,525,532,535,539,543,546,549,553,558,564,568,572,575,580,584,589,593,
    600,602,606,609,614,618,623,626,630,634,638,643,648,653,655,659,664,669,672,675,679,682,
    686,689,693,699,703,706,709,713,719,722,725,729,734,735,739,742,745,749,752,758,760,764,
    765,771,774,778,783,786,789,792,795,797,800,802,805,810,813,815,819,823,826,829,832,834,
    836,840,842,846,849,852,855,857,861,862,864,867,869,871,875,877,880,881,884,886,887,890,
    893,895,898};

const int fl_hadlock[] = //12w1d-42w0d
    {210, 10, 85,
        70,73,78,83,88,94,99,104,109,114,119,124,129,134,139,143,148,153,158,163,167,172,177,181,186,191,195,200,204,
    209,213,218,222,227,231,236,240,244,249,253,257,261,266,270,274,278,283,287,291,295,299,303,307,311,315,320,324,328,
    332,336,339,343,347,351,355,359,362,367,371,375,378,382,386,390,393,397,401,405,408,412,416,420,423,427,431,434,438,
    441,445,449,452,456,459,463,466,470,473,477,480,484,487,491,494,498,501,505,508,511,515,518,522,525,528,532,535,538,
    542,545,548,552,555,558,561,565,568,571,574,578,581,584,587,591,594,597,600,603,606,610,613,616,619,622,625,628,632,
    635,638,641,644,647,650,653,656,659,662,665,668,671,674,677,680,683,686,689,692,695,698,701,704,707,710,713,716,719,
    722,725,727,730,733,736,739,742,745,748,750,753,756,759,762,765,767,770,773,776,779,781,784,787,790,793,795,798,801,
    804,806,809,812,815,817,820};

const int fl_merz[] = //FL  12w2d-40w1d
    {196, 1, 86,
        10,10,10,11,11,11,11,12,12,13,14,14,15,15,15,16,16,17,17,17,18,18,19,19,19,20,20,21,21,21,22,22,23,23,24,24,24,25,
    25,26,26,26,27,27,28,28,28,29,29,29,30,30,31,31,31,32,32,32,33,33,34,34,35,35,35,36,36,37,37,37,38,38,38,39,39,39,
    40,40,41,41,41,42,42,43,43,43,44,44,44,45,45,45,46,46,46,47,47,48,48,48,49,49,50,50,50,51,51,51,52,52,52,53,53,53,
    54,54,54,55,55,55,56,56,56,57,57,58,58,58,59,59,59,60,60,60,60,61,61,62,62,62,63,63,63,63,64,64,65,65,65,66,66,66,
    66,67,67,67,68,68,68,69,69,69,70,70,70,71,71,71,72,72,72,72,73,73,73,74,74,74,75,75,75,76,76,76,76,77,77,77,78,78,
    78,79,79,79,79,80};

const int fl_jeanty[] = //FL*10 12w4d-40w0d
    {193, 10, 88,
        100,101,106,110,115,119,123,128,132,137,141,145,150,154,158,163,167,171,176,180,184,188,193,197,201,205,209,214,218,
    222,226,230,234,238,243,247,251,255,259,263,267,271,275,279,283,287,291,295,299,303,307,311,315,319,323,327,331,334,
    338,342,346,350,354,358,361,365,369,373,377,381,384,388,392,396,399,403,407,411,414,418,422,425,429,433,437,440,444,
    448,451,455,459,462,466,469,473,477,480,484,487,491,495,498,502,505,509,512,516,519,523,526,530,533,537,540,544,547,
    551,554,558,561,565,568,571,575,578,582,585,589,592,595,599,602,606,609,612,616,619,622,626,629,632,636,639,642,646,
    649,652,655,659,662,665,669,672,675,678,682,685,688,691,695,698,701,704,708,711,714,717,720,724,727,730,733,736,739,
    743,746,749,752,755,758,761,765,768,771,774,777,780,783,786,789,793,796,799};

const int fl_tokyo[] = //FL*10  20w3d-40w0d  138 in total
    {138, 10, 143,
        331,333,336,339,342,345,350,353,354,357,359,362,365,368,373,378,380,383,386,389,393,394,398,399,403,406,409,412,416,
    419,422,426,429,433,436,439,443,445,449,452,454,457,460,462,466,470,472,476,479,482,485,490,492,497,501,503,505,509,
    513,514,518,520,523,527,529,532,536,539,542,546,548,550,552,557,559,564,567,568,573,574,578,580,581,584,587,589,593,
    597,599,604,605,608,610,613,614,617,619,622,625,628,630,632,634,638,640,643,645,646,651,652,653,655,658,660,662,665,
    667,670,672,674,676,677,678,680,682,684,686,688,690,692,693,694,695,697,699,700,701,703};

const int crl_hadlock[] = //CRL*10  5w5d-18w0d
    {87, 10, 40,
        20,24,39,40,49,57,66,75,83,92,101,110,119,128,137,146,156,165,175,185,195,205,215,226,237,248,259,271,282,295,307,
    320,333,347,361,375,390,405,421,437,454,471,489,507,526,545,564,584,603,623,643,663,682,701,720,739,757,775,793,
    810,827,844,860,876,892,907,922,937,951,966,980,994,1008,1022,1035,1049,1063,1076,1090,1103,1117,1131,1144,1158,
    1173,1187,1202};

const int crl_robinson[] = //CLR*10 6w3d-13w6d 53
    {53, 10, 45,
        67,74,80,88,95,103,111,119,128,137,147,156,166,176,187,198,209,221,232,244,257,270,283,296,310,324,338,
    352,367,383,398,414,430,446,463,480,498,515,533,552,570,589,608,628,648,668,688,709,730,751,773,795,817};

const int crl_hansmenn[] = //CRL    6w1d-21w3d
    {108, 1, 43,
        6,7,7,8,8,9,10,10,11,12,13,13,14,15,15,16,17,18,19,20,21,22,23,24,24,26,26,28,28,30,32,32,34,36,36,38,40,
    42,44,44,46,48,50,52,54,56,58,60,63,63,66,70,70,73,76,76,80,83,83,86,86,90,90,93,93,96,96,100,100,103,103,106,106,
    110,110,110,113,113,116,116,120,120,120,123,123,126,126,126,126,130,130,133,133,133,136,136,136,140,140,140,143,143,
    143,146,146,146,146,150};

const int crl_lasser[] = //CRL*10   6w0d-14w1d
    {58, 10, 42,
        23,31,39,47,56,64,73,82,91,101,111,120,130,140,151,162,172,183,194,205,217,228,240,252,264,277,289,302,315,
    328,341,354,368,382,396,410,425,439,454,469,484,494,515,530,546,562,579,595,611,628,645,662,680,697,715,733,751,
    769};

const int crl_tokyo[] = // CRL*10   7w6d-12w2d   33 in total
    {33, 10, 55,
        131,135,146,155,167,177,185,195,206,216,226,235,246,255,276,286,296,307,315,327,346,355,365,376,395,407,416,436,446,
    456,476,486,500};

const int gs_hellman[] = //GS*10  6w0d-12w1d
    {44, 10, 42,
    170, 172,182,192,202,213,223,233,243,253,263,273,283,293,303,313,323,333,343,353,363,373,383,393,
    403,413,423,433,443,453,463,473,483,493,503,513,523,533,543,553,564,574,584,594};

const int gs_rempen[] = //GS    4w6d-14w1d
    {66, 1, 34,
    2,3,4,5,7,8,9,11,12,13,14,16,17,18,19,21,22,23,24,25,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,45,46,
    47,48,49,50,51,52,53,55,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,71,72,73};

const int gs_tokyo[] = //GSD*10 4w3d-10w2d  42 in total
    {42, 10, 31,
    120,128,136,146,154,158,166,176,184,189,196,207,216,226,234,239,246,256,265,277,285,296,306,314,319,325,336,
    346,356,367,376,385,396,407,415,436,447,457,466,476,487,497};

const int ac_hadlock[] = //AC*10    12w0d-42w0d
    {211, 10, 84,
        500,510,528,546,564,582,600,618,636,654,672,690,707,725,743,761,778,796,814,831,849,866,884,901,919,936,953,
    971,988,1006,1023,1040,1057,1075,1092,1109,1126,1143,1160,1177,1194,1211,1228,1245,1262,1279,1296,1313,1330,
    1347,1363,1380,1397,1414,1430,1447,1464,1480,1497,1514,1530,1547,1563,1580,1596,1613,1629,1645,1662,1678,1694,
    1711,1727,1743,1760,1776,1792,1808,1824,1841,1857,1873,1889,1905,1921,1937,1953,1969,1985,2001,2017,2033,2049,
    2064,2080,2096,2112,2128,2143,2159,2175,2190,2206,2222,2237,2253,2269,2284,2300,2315,2331,2346,2362,2377,2393,
    2408,2424,2439,2454,2470,2485,2500,2516,2531,2546,2562,2577,2592,2607,2622,2638,2653,2668,2683,2698,2713,2728,
    2743,2758,2773,2788,2803,2818,2833,2848,2863,2878,2893,2907,2922,2937,2952,2967,2981,2996,3011,3026,3040,3055,
    3070,3084,3099,3114,3128,3143,3157,3172,3187,3201,3216,3230,3245,3259,3274,3288,3302,3317,3331,3346,3360,3374,
    3389,3403,3417,3432,3446,3460,3474,3489,3503,3517,3531,3545,3560,3574,3588,3602,3616,3630,3644,3658,3672,3686,
    3700,3714,3728,3742,3756,3770,3784,3798};

const int ac_merz[] = //AC  12w1d-39w6d
    {196, 1, 85,
        56,58,58,60,62,64,64,66,68,68,70,72,74,76,78,78,80,82,82,84,86,88,88,90,92,94,96,96,98,100,100,102,104,106,
    106,108,110,112,114,114,116,118,120,120,122,124,124,126,128,130,132,132,134,136,138,138,140,142,142,144,146,
    148,148,150,152,154,156,156,158,160,162,162,164,166,166,168,170,172,174,174,176,178,180,180,182,184,184,186,
    188,190,190,192,194,194,196,198,198,200,202,204,204,206,208,208,210,212,214,216,216,218,220,222,222,224,226,
    226,228,230,232,234,236,236,238,240,240,242,244,246,246,248,250,250,252,254,256,258,258,260,262,264,264,266,
    268,268,270,272,274,276,278,278,280,282,282,284,286,288,288,290,292,294,296,296,298,300,300,302,304,306,306,
    308,310,310,312,314,316,318,320,320,322,324,324,326,328,330,330,332,334,336,338,338,340,342,342,344,346,348};

const int ac_lasser[] = //AC*10 8w5d-14w2d  40
    {40, 10, 61,
        309,317,324,332,340,347,356,364,372,381,390,399,408,418,427,437,448,458,469,480,491,502,514,526,538,551,564,
    577,590,604,618,632,647,662,677,693,709,726,743,760};

const int ac_tokyo[] = // AC*10 15w3d-41w0d  180 in total
    {180, 10, 108,
        1003,1009,1020,1037,1048,1060,1076,1082,1099,1111,
    1128,1147,1158,1170,1182,1199,1211,1227,1245,1257,
    1273,1284,1297,1309,1328,1347,1360,1373,1386,1399,
    1412,1431,1444,1465,1478,1498,1507,1522,1533,1546,
    1569,1578,1596,1614,1624,1635,1646,1662,1683,1696,
    1711,1726,1747,1757,1773,1784,1795,1811,1828,1845,
    1862,1879,1884,1896,1913,1935,1946,1957,1974,1985,
    1997,2014,2025,2042,2059,2070,2087,2099,2116,2128,
    2133,2145,2168,2180,2202,2208,2220,2232,2249,2261,
    2272,2284,2295,2314,2326,2344,2362,2375,2386,2397,
    2409,2419,2436,2447,2458,2473,2484,2500,2511,2522,
    2532,2549,2560,2571,2582,2599,2610,2622,2633,2644,
    2656,2667,2679,2690,2696,2707,2724,2736,2747,2764,
    2770,2787,2804,2810,2815,2827,2838,2849,2867,2872,
    2884,2895,2906,2918,2929,2935,2946,3011,3017,3021,
    3024,3029,3035,3038,3041,3046,3052,3057,3075,3086,
    3103,3109,3121,3127,3139,3150,3156,3167,3179,3185,
    3190,3196,3208,3218,3229,3240,3246,3263,3269,3280};

const int hc_hadlock[] = //HC*10    12w0d-42w0d
    {211, 10, 84,
        560,567,592,617,641,666,691,715,739,764,788,812,835,859,882,906,929,952,975,998,1020,1043,1065,1087,1109,1131,1153,
    1175,1196,1217,1238,1259,1280,1301,1322,1342,1362,1382,1402,1422,1442,1462,1481,1500,1520,1539,1557,1576,1595,1613,
    1632,1650,1668,1686,1704,1722,1740,1757,1774,1792,1809,1826,1843,1860,1877,1893,1910,1926,1942,1959,1975,1991,2007,
    2022,2038,2054,2069,2084,2100,2115,2130,2145,2160,2175,2190,2204,2219,2233,2248,2262,2276,2290,2305,2319,2332,2346,
    2360,2374,2387,2401,2414,2428,2441,2454,2467,2481,2494,2507,2519,2532,2545,2558,2570,2583,2595,2608,2620,2633,2645,
    2657,2669,2681,2693,2705,2717,2729,2741,2752,2764,2776,2787,2799,2810,2822,2833,2844,2855,2867,2878,2889,2900,2911,
    2922,2933,2944,2954,2965,2976,2986,2997,3008,3018,3029,3039,3050,3060,3070,3080,3091,3101,3111,3121,3131,3141,3151,
    3161,3171,3181,3191,3201,3210,3220,3230,3239,3249,3259,3268,3278,3287,3296,3306,3315,3325,3334,3343,3352,3362,3371,
    3380,3389,3398,3407,3416,3425,3434,3443,3452,3461,3469,3478,3487,3496,3504,3513,3522,3530,3539,3547,3556,3564,3573};

const int hc_merz[] = //HC*10   12w1d-40w4d
    {199, 1, 85,
        72,74,76,78,80,82,84,86,90,92,94,96,98,100,102,104,106,108,110,112,114,116,118,120,122,124,126,128,130,132,134,136,
    138,140,142,144,146,146,148,152,154,156,156,160,162,164,166,168,170,172,174,176,176,178,180,182,184,186,188,190,192,
    192,194,196,198,200,202,204,204,206,208,210,212,214,216,216,218,220,220,224,226,228,230,230,232,234,236,238,238,240,
    242,242,244,246,248,250,252,252,254,256,256,258,260,262,262,262,264,266,266,268,268,270,272,272,274,276,278,278,280,
    282,282,284,284,286,288,290,290,290,292,294,296,296,298,298,300,302,302,304,304,306,308,308,310,310,312,312,314,314,
    316,318,318,320,320,322,322,324,324,326,328,328,330,330,330,332,332,334,334,336,336,338,340,340,342,342,344,344,344,
    346,346,348,348,350,350,350,352,352,354,354,356,356,356,358,358,360,360,362,362,362,364};

const int hc_lasser[] =//HC*10 40   8w5d-14w2d
    {40, 10, 61,
        353,368,382,397,412,427,442,456,471,486,500,516,530,545,560,575,590,604,619,634,649,664,678,693,708,723,738,
    752,767,782,797,812,826,841,856,871,886,900,915,930};

const int tad_merz[] = //12w0d
    {197, 10, 84,
        130, 193, 200, 204, 211, 217, 222, 227, 233, 237, 241, 246, 250, 254,
    259, 263, 267, 272, 276, 280, 284, 288, 292, 297, 302, 306, 309, 314,
    318, 323, 328, 335, 340, 346, 352, 357, 362, 367, 371, 376, 381, 384,
    388, 393, 398, 403, 407, 410, 415, 419, 424, 428, 432, 437, 440, 444,
    449, 454, 459, 465, 470, 476, 481, 487, 493, 498, 504, 508, 513, 517,
    521, 524, 528, 531, 536, 539, 543, 549, 554, 557, 562, 566, 570, 575,
    579, 584, 589, 594, 600, 608, 615, 621, 625, 628, 632, 639, 641, 648,
    650, 653, 657, 662, 668, 671, 674, 679, 684, 690, 696, 702, 707, 717,
    721, 725, 728, 732, 737, 741, 747, 751, 756, 760, 763, 767, 770, 775,
    779, 786, 790, 795, 799, 802, 806, 809, 813, 822, 828, 831, 839, 845,
    847, 856, 860, 862, 869, 873, 876, 879, 883, 889, 893, 898, 902, 907,
    912, 914, 920, 924, 929, 932, 938, 944, 948, 952, 959, 962, 967, 972,
    979, 984, 988, 993, 998, 1000, 1005, 1010, 1015, 1020, 1025, 1030, 1032, 1034, 1036,
    1040, 1050, 1055, 1060, 1070, 1073, 1076, 1080, 1090, 1093, 1096, 1100, 1110, 1120};

const int apad_merz[] =   //12w0d
    {197, 10, 84,
    120, 183, 185, 192, 196, 200, 204, 208, 212, 217, 222, 225, 228, 237,
    238, 243, 249, 254, 261, 266, 272, 277, 283, 287, 291, 295, 299, 304,
    309, 313, 317, 321, 325, 330, 334, 339, 342, 347, 351, 356, 359, 364,
    368, 373, 379, 384, 390, 396, 402, 407, 412, 417, 422, 426, 429, 434,
    438, 442, 447, 452, 456, 459, 464, 469, 472, 477, 481, 485, 489, 494,
    499, 503, 509, 514, 520, 526, 532, 537, 543, 547, 552, 556, 560, 564,
    569, 572, 577, 581, 586, 590, 594, 599, 604, 609, 615, 621, 627, 632,
    637, 642, 647, 652, 655, 660, 664, 668, 672, 677, 682, 686, 690, 694,
    699, 702, 707, 712, 716, 719, 724, 728, 734, 739, 744, 750, 757, 762,
    768, 772, 777, 781, 785, 789, 794, 799, 802, 807, 812, 815, 819, 824,
    828, 833, 837, 841, 845, 850, 854, 859, 864, 869, 875, 881, 887, 892,
    898, 903, 907, 912, 915, 919, 924, 928, 933, 937, 942, 945, 950, 954,
    959, 962, 967, 971, 975, 980, 984, 989, 994, 999, 1010, 1015, 1020, 1023, 1026, 1030,
    1035, 1040, 1045, 1050, 1055, 1060, 1063, 1066, 1070, 1075, 1080, 1085, 1090};

const int thd_hansmenn[] =  //14w0d
    {183, 10, 98,
        215, 259, 266, 269, 272, 278, 283, 287, 291, 296, 301, 307, 313, 317,
    322, 328, 332, 335, 340, 346, 350, 356, 361, 365, 371, 377, 380, 385,
    390, 394, 398, 404, 407, 410, 415, 420, 425, 430, 436, 440, 443, 446,
    450, 455, 460, 465, 468, 473, 477, 482, 487, 494, 498, 502, 506, 512,
    516, 519, 524, 529, 533, 537, 543, 547, 552, 556, 562, 565, 569, 573,
    579, 585, 589, 593, 597, 601, 606, 610, 614, 618, 621, 627, 631, 636,
    642, 645, 648, 652, 656, 661, 665, 670, 675, 679, 683, 687, 693, 696,
    700, 704, 709, 713, 717, 720, 725, 729, 734, 739, 742, 747, 752, 757,
    760, 765, 770, 772, 776, 781, 785, 789, 793, 797, 803, 806, 810, 815,
    818, 820, 824, 829, 833, 837, 840, 845, 850, 854, 857, 860, 865, 868,
    870, 875, 879, 883, 888, 892, 897, 900, 903, 907, 910, 915, 920, 923,
    927, 930, 935, 938, 943, 948, 952, 955, 960, 962, 966, 969, 971, 974,
    979, 982, 985, 988, 993, 996, 999, 1003, 1006, 1010, 1015, 1020, 1023,
    1026, 1030};

const int ofd_korean[] =  //8w0d
    {225, 10, 56,
    5, 12, 20, 28, 36, 44, 52, 61, 69, 77, 85, 93, 101, 109, 117, 125, 133, 141, 149, 157, 165, 173, 181, 189, 197, 205,
    213, 221, 229, 237, 245, 253, 261, 269, 277, 285, 293, 300, 308, 315, 322, 329, 336, 343, 350, 357, 364, 371, 378,
    385, 392, 399, 406, 413, 420, 426, 432, 438, 444, 450, 456, 462, 468, 474, 480,486, 492, 498, 504, 509, 515, 521,
    526, 532, 538, 543, 549, 555, 560, 566, 572, 577, 583, 589, 594, 600, 606, 611, 617, 623, 628, 634, 640, 645, 651,
    657, 662, 668,674, 679, 685, 691, 696, 702, 708, 713, 719, 724, 729, 735, 740, 745, 751, 756, 761, 767, 772, 777,
    783, 788, 793, 799, 804, 809, 815, 820, 825, 829, 834, 839, 843,848, 853, 857, 862, 867, 871, 876, 881, 885, 890,
    895, 899, 904, 909, 913, 918, 923, 927, 932, 937, 941, 946, 951, 955, 960, 965, 969, 974, 979, 983, 988, 993, 998,
    1003, 1008, 1013, 1018, 1023, 1028, 1032, 1037, 1042, 1046, 1050, 1055, 1059, 1063, 1068, 1072, 1076, 1081, 1085,
    1089, 1094, 1098, 1102, 1107, 1111, 1115, 1120,1124, 1128, 1133, 1137, 1141, 1146, 1150, 1154, 1158, 1162, 1167,
    1171, 1175, 1180, 1184, 1188, 1193, 1197, 1201, 1205, 1210, 1214, 1218, 1222, 1226, 1230, 1234,1238, 1242, 1246,
    1250, 1254, 1258, 1262};

const int ood_jeanty[] = {
    208, 10, 74,
    151, 154, 157, 160, 162, 164, 166, 168, 171, 174, 177, 179, 182, 184, 186, 188, 190, 191, 193, 196,
    199, 202, 204, 206, 208, 211, 213, 216, 219, 222, 224, 226, 228, 231, 233, 236, 238, 240, 242, 244,
    246, 248, 251, 253, 256, 258, 261, 264, 267, 274, 275, 277, 278, 280, 281, 283, 286, 288, 290, 293,
    295, 297, 299, 301, 303, 306, 308, 312, 315, 317, 319, 322, 324, 327, 329, 332, 334, 336, 339, 341,
    344, 347, 349, 352, 354, 356, 359, 361, 363, 365, 368, 370, 372, 375, 377, 379, 381, 383, 386, 388,
    391, 393, 396, 398, 401, 404, 407, 409, 412, 414, 416, 418, 420, 422, 424, 427, 429, 432, 434, 437,
    439, 441, 443, 446, 449, 452, 454, 456, 458, 460, 463, 465, 467, 469, 471, 474, 476, 479, 482, 485,
    487, 490, 492, 494, 497, 499, 501, 504, 506, 509, 511, 514, 516, 518, 520, 522, 526, 530, 532, 535,
    537, 539, 541, 543, 546, 549, 552, 554, 556, 558, 560, 563, 565, 567, 569, 571, 573, 576, 578, 581,
    583, 586, 589, 592, 595, 597, 600, 602, 604, 605, 607, 610, 612, 615, 617, 619, 622, 624, 626, 628,
    631, 633, 636, 639, 641, 644, 646, 649
};

const int tibia_jeanty[] = {
    183, 10, 96,
    107, 111, 115, 119, 123, 127, 131, 135, 139, 143, 148, 152, 156, 161, 165, 170, 174, 179, 182, 184,
    187, 191, 194, 198, 202, 206, 210, 213, 217, 220, 224, 227, 231, 234, 237, 244, 250, 252, 254, 258,
    261, 265, 269, 272, 276, 279, 282, 285, 289, 292, 295, 297, 301, 305, 308, 311, 314, 317, 322, 326,
    331, 335, 339, 342, 344, 347, 349, 352, 354, 358, 362, 366, 371, 375, 378, 380, 383, 385, 389, 393,
    396, 399, 402, 405, 409, 412, 416, 419, 422, 425, 428, 431, 434, 436, 438, 442, 445, 448, 452, 455,
    458, 460, 463, 466, 469, 472, 474, 479, 483, 486, 488, 491, 495, 498, 501, 503, 506, 509, 512, 515,
    518, 521, 524, 527, 530, 533, 535, 538, 542, 545, 547, 550, 552, 555, 559, 562, 564, 567, 569, 572,
    575, 578, 581, 584, 586, 589, 592, 595, 598, 601, 603, 606, 609, 612, 615, 618, 622, 624, 625, 627,
    629, 631, 586, 540, 593, 645, 647, 649, 651, 654, 657, 660, 663, 666, 668, 671, 673, 676, 679, 682,
    684, 686, 688
};

const int ttd_hansmenn[] = {//Transverse Thoracic Diameter胸横径
    197, 10, 84,
    170, 173, 176, 181, 185, 190, 195, 200, 204, 209, 215, 220, 225, 229, 236, 243, 247, 251, 255, 260,
    265, 268, 271, 277, 284, 290, 295, 300, 306, 311, 317, 322, 326, 329, 334, 338, 342, 345, 349, 353,
    358, 362, 366, 371, 375, 380, 385, 390, 394, 398, 402, 408, 414, 420, 427, 433, 437, 441, 445, 451,
    456, 460, 465, 469, 472, 476, 479, 484, 490, 495, 499, 504, 508, 512, 517, 521, 526, 530, 534, 537,
    541, 545, 549, 553, 558, 562, 567, 571, 575, 580, 584, 589, 593, 598, 602, 606, 610, 613, 617, 621,
    625, 629, 634, 639, 644, 650, 655, 661, 666, 672, 677, 682, 686, 690, 695, 699, 705, 711, 715, 718,
    722, 724, 727, 729, 733, 737, 740, 743, 749, 754, 760, 765, 772, 779, 782, 785, 791, 796, 800, 803,
    807, 813, 815, 817, 819, 823, 826, 830, 833, 838, 842, 845, 848, 853, 857, 862, 867, 871, 875, 878,
    882, 887, 891, 896, 901, 906, 911, 915, 918, 922, 925, 927, 929, 933, 936, 940, 943, 946, 950, 953,
    958, 963, 967, 971, 975, 977, 980, 982, 986, 989, 993, 996, 998, 1000, 1002, 1005, 1008
};

const int ulna_jeanty[] = {
    190, 10, 93,
    101, 105, 108, 112, 117, 122, 127, 131, 135, 138, 142, 145, 149, 152, 155, 158, 162, 167, 171, 175,
    178, 182, 185, 187, 192, 196, 201, 205, 209, 213, 216, 218, 221, 225, 228, 231, 234, 237, 241, 245,
    248, 252, 255, 258, 261, 265, 269, 273, 276, 279, 282, 285, 288, 292, 295, 298, 301, 304, 307, 309,
    312, 315, 318, 321, 324, 327, 329, 331, 334, 338, 341, 344, 352, 353, 355, 356, 360, 363, 366, 369,
    372, 375, 377, 380, 382, 384, 387, 391, 394, 396, 399, 401, 404, 406, 409, 411, 415, 418, 422, 424,
    426, 428, 431, 433, 436, 438, 441, 444, 447, 450, 452, 454, 456, 459, 462, 464, 467, 470, 473, 476,
    478, 480, 482, 485, 487, 489, 492, 494, 497, 501, 504, 506, 509, 511, 513, 515, 517, 519, 522, 524,
    527, 529, 532, 534, 537, 539, 541, 544, 546, 549, 551, 554, 556, 559, 561, 563, 565, 568, 570, 572,
    575, 577, 579, 582, 584, 586, 587, 589, 592, 594, 597, 599, 602, 604, 606, 609, 611, 613, 616, 618,
    620, 622, 625, 627, 630, 632, 634, 635, 637, 639
};
//14w0d
const int fta_osaka[] = {
    27, 1, 98,
    560, 730, 920, 1130, 1350, 1580, 1840, 2100, 2380, 2680, 2990, 3310, 3650,
    3990, 4340, 4710, 5080, 5450, 5830, 6210, 6580, 6950, 7320, 7680, 8020, 8350,
    8660
};

#ifdef VET
//============================Animal OB Measure Tables=======================================//
const int SheepCRL[][2] =
{
    {10, 0},
    {137,28},{145,29},{165,30},{190,31},{214,32},{235,33},{251,34},{276,35},{301,36},{326,37},
    {346,38},{367,39},{391,40},{416,41},{440,42},{465,43},{494,44},{523,45},{551,46},{580,47},
    {609,48},{638,49},{675,50},{695,51},{724,52},{752,53},{781,54},{814,55},{839,56},{868,57},
    {900,58},{925,59},{954,60},{983,61},{1011,62},{1036,63},{1064,64},{1090,65},{1116,66},{1143,67},
    {1170,68},{1198,69},{1223,70},{0,0}
};

const int SwineHLA[][2] =
{
    {10, 0},
    {31,21},{35,22},{40,24},{47,26},{52,28},{57,30},{60,31},{67,33},{75,36},{79,37},
    {83,39},{91,41},{100,44},{104,46},{108,47},{112,49},{121,52},{129,54},{137,57},{145,60},
    {153,63},{166,67},{170,69},{174,70},{182,73},{190,76},{194,77},{199,79},{211,83},{215,84},
    {223,87},{231,90},{239,93},{252,97},{260,100},{272,104},{280,107},{288,109},{293,111},{0,0}
};

const int SwineSLA[][2] =
{
    {10, 0},
    {21,21},{31,24},{39,26},{48,29},{55,30},{63,33},{71,35},{80,37},{88,39},{95,41},
    {104,43},{116,46},{124,49},{132,51},{140,53},{149,55},{157,57},{165,59},{173,62},{186,65},
    {194,67},{202,69},{211,72},{222,74},{230,77},{247,81},{255,83},{263,85},{271,87},{280,90},
    {288,92},{300,95},{308,97},{317,99},{325,101},{333,104},{345,107},{358,110},{363,111},{0,0}
};

const int BovineCRL_H[][2] =
{
    {10, 0},
    {90,28},{102,30},{112,32},{123,34},{138,36},{155,38},{179,40},{214,43},{234,45},{258,47},
    {278,49},{319,51},{380,53},{425,55},{475,57},{526,59},{566,61},{612,63},{678,65},{754,67},
    {823,69},{892,71},{945,73},{999,74},{1032,76},{1079,78},{1123,80},{1168,81},{1188,83},{1211,84},{0,0}
};

const int BovineCRL_K[][2] =
{
    {10, 0},
    {75,30},{85,31},{109,33},{130,35},{159,37},{190,39},{223,41},{238,42},{274,44},{308,46},
    {341,48},{381,50},{420,52},{462,54},{512,56},{555,58},{598,60},{650,62},{701,64},{747,66},
    {804,68},{857,70},{910,72},{970,74},{1027,76},{1089,78},{1151,80},{0,0}
};

const int BovineCRL_W[][2] =
{
    {10, 0},
    {130,28},{142,30},{152,32},{171,34},{185,36},{210,38},{229,40},{251,42},{282,44},{308,46},
    {331,47},{360,49},{393,51},{432,53},{485,55},{525,57},{582,59},{639,61},{707,63},{780,65},
    {865,67},{949,69},{1055,71},{1158,73},{1281,75},{1344,76},{1426,77},{1484,78},{1558,79},{1637,80},
    {1730,81},{0,0}
};

const int BovineBBD[][2] =
{
    {10, 0},
    {176,60},{183,62},{195,64},{205,66},{214,68},{229,70},{243,73},{252,75},{265,77},{275,79},
    {285,81},{295,83},{305,85},{317,87},{327,89},{341,92},{354,94},{369,97},{384,100},{398,103},
    {415,106},{432,109},{449,112},{463,115},{479,118},{494,121},{507,124},{528,127},{539,130},{555,133},
    {572,136},{588,139},{604,142},{619,145},{634,148},{654,151},{668,154},{682,157},{695,160},{712,163},
    {731,166},{745,169},{761,172},{774,175},{790,178},{809,181},{824,184},{837,187},{856,190},{868,193},
    {885,196},{900,199},{915,202},{936,205},{947,208},{953,209},{0,0}
};

const int BovineBTD[][2] =
{
    {10, 0},
    {203,65},{223,69},{242,72},{262,76},{282,79},{307,82},{326,85},{351,88},{381,91},{410,94},
    {445,97},{474,100},{504,103},{554,106},{588,109},{618,111},{667,114},{711,117},{756,119},{830,123},
    {884,126},{959,129},{1023,132},{1097,135},{1157,137},{0,0}
};

const int BovineBUD[][2] =
{
    {10, 0},
    {192,31},{204,34},{225,38},{239,41},{255,44},{274,47},{292,50},{308,53},{327,56},{349,59},
    {378,62},{398,65},{424,68},{461,72},{494,75},{526,78},{565,81},{602,84},{642,87},{685,90},
    {722,93},{775,96},{809,98},{866,101},{920,104},{983,107},{1046,110},{1119,113},{1202,116},{1278,119},
    {1350,122},{1448,125},{1539,128},{1617,130},{0,0}
};

const int EquineGSD[][2] =
{
    {10, 0},
    {7,3},{52,6},{91,9},{137,12},{183,15},{222,18},{280,21},{313,24},{365,27},{404,30},
    {457,33},{496,36},{541,39},{582,41},{0,0}
};

const int EquineERD[][2] =
{
    {10, 0},
    {7,42},{52,46},{91,50},{144,54},{183,58},{222,62},{261,66},{300,70},{339,74},{378,78},
    {417,82},{450,86},{483,90},{515,94},{541,98},{567,102},{600,106},{626,110},{652,114},{672,118},
    {698,122},{717,126},{737,130},{757,134},{773,138},{789,142},{802,146},{815,150},{828,154},{841,159},
    {848,161},{861,168},{868,172},{875,177},{0,0}
};

const int EquineESD[][2] =
{
    {10, 0},
    {184,80},{188,82},{200,87},{204,89},{211,92},{215,94},{222,96},{225,98},{233,101},{240,104},
    {251,107},{258,110},{266,113},{276,116},{284,119},{293,122},{305,125},{312,128},{323,131},{334,134},
    {345,137},{356,140},{366,143},{378,146},{388,149},{399,152},{414,155},{425,158},{436,161},{451,164},
    {463,167},{478,170},{489,173},{503,176},{518,179},{530,182},{544,185},{559,188},{575,191},{590,194},
    {605,197},{620,200},{639,203},{654,206},{670,209},{0,0}
};

const int EquineEED[][2] =
{
    {10, 0},
    {118,79},{124,83},{130,87},{135,91},{141,95},{147,99},{153,103},{157,107},{163,111},{168,115},
    {174,119},{180,123},{185,127},{191,131},{202,139},{208,143},{214,147},{219,151},{225,155},{229,159},
    {235,163},{242,167},{248,171},{252,175},{258,179},{264,183},{270,187},{276,192},{282,196},{288,200},
    {294,204},{300,208},{305,213},{311,217},{320,223},{326,228},{332,232},{338,236},{344,240},{350,244},
    {356,249},{362,253},{368,257},{374,261},{382,268},{388,272},{394,276},{400,280},{406,285},{412,289},
    {418,293},{421,295},{427,299},{430,302},{436,306},{442,310},{448,314},{454,318},{459,323},{466,327},{0,0}
};

const int DogGSD[][2] =
{
    {10, 0},
    {14,21},{53,23},{82,25},{112,27},{145,29},{181,31},{219,33},{251,35},{278,37},{313,39},{326,40},{0,0}
};

const int DogHD[][2] =
{
    {10, 0},
    {132,40},{144,42},{157,44},{172,46},{187,48},{198,50},{212,52},{224,54},{238,56},{253,58},
    {268,60},{282,62},{294,64},{300,65},{0,0}
};

const int DogCRL[][2] =
{
    {10, 0},
    {13,27},{22,28},{55,29},{91,30},{118,31},{151,32},{186,33},{218,34},{256,35},{289,36},
    {322,37},{352,38},{384,39},{419,40},{0,0}
};

const int DogBD[][2] =
{
    {10, 0},
    {154,40},{181,42},{214,44},{242,46},{265,48},{298,50},{324,52},{354,54},{384,56},{407,58},
    {437,60},{472,62},{496,64},{509,65},{0,0}
};

const int CatHD[][2] =
{
    {10, 0},
    {150,41},{159,43},{168,45},{177,47},{183,49},{191,51},{200,53},{209,55},{217,57},{223,59},{232,61},{238,63},{248,65},{0,0}
};

const int CatBD[][2] =
{
    {10, 0},
    {185,41},{196,43},{214,45},{235,47},{255,49},{270,51},{288,53},{305,55},{326,57},{347,59},{365,61},{386,63},{398,65},{0,0}
};
#endif
const int *GWMethodLine[] = {
    cer_goldstein, cer_custom,
    hl_jeanty, hl_custom,
    bpd_hadlock, bpd_merz, bpd_lasser, bpd_rempen, bpd_tokyo, bpd_custom,
    fl_hadlock, fl_merz, fl_jeanty, fl_tokyo, fl_custom,
    crl_hadlock, crl_robinson, crl_hansmenn, crl_lasser, crl_tokyo, crl_custom,
    gs_hellman, gs_rempen, gs_tokyo, gs_custom,
    ac_hadlock, ac_merz, ac_lasser, ac_tokyo, ac_custom,
    hc_hadlock, hc_merz, hc_lasser, hc_custom,
    tad_merz, tad_custom,
    apad_merz, apad_custom,
    thd_hansmenn, thd_custom,
    ofd_korean, ofd_custom,
    ood_jeanty, ood_custom,
    tibia_jeanty, tibia_custom,
    ttd_hansmenn, ttd_custom,
    ulna_jeanty, ulna_custom,
    fta_osaka, fta_custom
};

#ifdef VET
typedef const int ObTableVet[2];
const ObTableVet *GWMethodLineVet[] = {
    DogGSD, DogCRL, DogHD, DogBD,
    CatHD,CatBD,
    SheepCRL,
    SwineHLA,SwineSLA,
    BovineCRL_K,BovineCRL_W,BovineCRL_H, BovineBBD,BovineBTD,BovineBUD,
    EquineGSD,EquineERD,EquineESD,EquineEED,
};
#endif

#ifdef VET
/*
const int DogDOP = 65;
const int CatDOP = 65;
const int SheepDOP = 70;
const int SwineDOP = 111;
const int BovineDOP = 209;
const int EquineDOP = 327;
*/
const int DogDOP = 65;
const int CatDOP = 65;
const int SheepDOP = 150;
//const int SwineDOP = 114;
const int BovineDOP = 280;
const int SwineDOP = 114;
//const int BovineDOP = 280;
const int EquineDOP = 340;
#endif
}

MeaResult *MeaCalcFun::m_ptrMeaResult = NULL;

MeaCalcFun::MeaCalcFun()
{
}

MeaCalcFun::~MeaCalcFun()
{
}

int MeaCalcFun::DoNothing(double data[], double *result, int state, int item, int save)
{
    return MEA_SUCCESS;
}

/* 函数功能：从存储测量值的数组中获取参与计算的测量值
 * 返回值：MEA_SUCCESS, MEA_FAIL, MEA_ERROR
 * currvalue：传入在测量中，本测量项的当前值
 * allItem[]：各测量值的枚举号，如果是测量中，第一个位置存储当前测量项的枚举号
 * value[]：存放要获取的各个测量值，测量值的存储位置要和allItem中的枚举号一一对应
 * itemNum：传入测量项的个数
 * state：IN_MEASURE－测量中，IN_REPORT－报告中
 * */
int MeaCalcFun::CalcGetValue(const double currValue, double value[][MEA_MULTI], const int allItem[], const int currItem, const int itemNums, const int state)
{
    int i;
    int sign;
    int noError = 0;

    if (state == IN_MEASURE)//测量中
    {
        for(i=0; i<itemNums; i++)
        {
            if (currItem != allItem[i])
            {
                sign = m_ptrMeaResult->GetValue(allItem[i], *(value+i), NULL, state);
                if (sign != MEA_SUCCESS) return sign;
            }
            else
            {
                value[i][0] = currValue;
                noError++;
            }
        }
        if (noError != 1) return MEA_ERROR;//allItem中没有和currItem相等或有多次相等的，说明编程时枚举号参数弄错了
    }
    else if (state == IN_REPORT_MEAN)
    {
        for(i=0; i<itemNums; i++)
        {
            sign = m_ptrMeaResult->GetValue(allItem[i], *(value+i), NULL, state);
            if (sign != MEA_SUCCESS) return sign;
        }
    }

    return MEA_SUCCESS;
}

#define CHECK1PAR(data1) ((int)data1 != INVALID_VAL)
#define CHECK2PAR(data1, data2) (((int)data1!=INVALID_VAL) && ((int)data2!=INVALID_VAL))
#define CHECK3PAR(data1, data2, data3) (((int)data1!=INVALID_VAL) && ((int)data2!=INVALID_VAL) && ((int)data3!=INVALID_VAL))
#define CHECK4PAR(data1, data2, data3, data4) (((int)data1!=INVALID_VAL) && ((int)data2!=INVALID_VAL) && ((int)data3!=INVALID_VAL) && ((int)data4!=INVALID_VAL))

#define GENERAL_PISA_F(diam) (CHECK1PAR(diam) ? (2*PI * diam * diam ) : (double)INVALID_VAL)
#define GENERAL_AREA_F(diam) (CHECK1PAR(diam) ? (PI * diam * diam / 4.0) : (double)INVALID_VAL)
#define GENERAL_VOL_F(l, w, h) (CHECK3PAR(l, w, h) ? (1.0/6.0 * PI * l * w * h) : (double)INVALID_VAL)  //适用于腹部，妇科，产科的体积计算
#define PELLET_VOL_F(diam) (CHECK1PAR(diam) ? (1.0/6.0 * PI * diam * diam * diam) : (double)INVALID_VAL)    //适用于腹部，妇科，产科的体积计算
#define GENERAL_RATIO_F(data1, data2) ((CHECK2PAR(data1, data2)&&(data2 > ZERO)) ? (data1 / data2) : (double)INVALID_VAL)

#define ADULT_AVA_VMAX_F(lvotArea, lvotVmax, avVmax) (CHECK3PAR(lvotArea, lvotVmax, avVmax) ? (lvotArea * lvotVmax / avVmax) : (double)INVALID_VAL)//*************//
#define ADULT_EDV_ESV_CUBED_F(lvidd_s) (CHECK1PAR(lvidd_s) ? (lvidd_s * lvidd_s * lvidd_s) : (double)INVALID_VAL)//Cubed公式
#define ADULT_EDV_ESV_TEICH_F(lvidd_s) (CHECK1PAR(lvidd_s) ? (((lvidd_s) * (lvidd_s) * (lvidd_s) * 7) / (2.4 + lvidd_s)) : (double)INVALID_VAL)//Teich公式
//注意：(EDV和ESV的BP方法少公式，A/L方法是多项测量的计算，还没做好)
#define ADULT_EF_F(edv, esv) ((CHECK2PAR(edv, esv)&&(edv > ZERO)) ? ((edv - esv) * 100.0 / edv) : (double)INVALID_VAL)//*************//
#define ADULT_SV_F(edv, esv) (CHECK2PAR(edv, esv) ? (edv - esv) : (double)INVALID_VAL)//*************//
#define ADULT_SI_F(sv, bsa) ((CHECK2PAR(sv, bsa)&&(bsa > ZERO)) ? (sv / bsa) : (double)INVALID_VAL)//*************//
#define ADULT_CO_F(sv, hr) (CHECK2PAR(sv, hr) ? (sv * hr) / 1000.0 : (double)INVALID_VAL)//*************//
#define ADULT_CI_F(co, bsa) ((CHECK2PAR(co, bsa)&&(bsa > ZERO)) ? (co / bsa) : (double)INVALID_VAL)//*************//
#define ADULT_FS_F(lvidd, lvids) ((CHECK2PAR(lvidd, lvids)&&(lvidd > ZERO)) ? ((lvidd - lvids) * 100.0 / lvidd) : (double)INVALID_VAL)//2D-Cubed,2D-Teich,MM-Cubed,MM-Teich均为此公式
#define ADULT_IVS_PER_F(ivsd, ivss) ((CHECK2PAR(ivss, ivsd)&&(ivsd > ZERO)) ? ((ivss - ivsd) * 100.0 / ivsd) : (double)INVALID_VAL)
#define ADULT_IVS_LVPW_RATIO_F(ivsd, lvpwd) ((CHECK2PAR(ivsd, lvpwd)&&(lvpwd > ZERO)) ? (ivsd / lvpwd) : (double)INVALID_VAL)
#define ADULT_LA_AO_RATIO_F(la, ao) ((CHECK2PAR(la, ao)&&(ao > ZERO)) ? (la / ao) : (double)INVALID_VAL)
//#define ADULT_LVMASS_AL_F() ()//LV Mass可能需要单独做，参数太多
//#define ADULT_LVMASS_CUBED_F(ivsd, lvidd, lvpwd) (CHECK3PAR(ivsd, lvidd, lvpwd) ? (0.8 * 1.04 *( pow((double)(ivsd/10.0 + lvidd/10.0 + lvpwd/10.0), 3.0 ) - pow((double)lvidd/10.0, 3.0) ) + 0.6) : (double)INVALID_VAL)//参数均应以cm为单位
#define ADULT_LVMASS_F(ivsd, lvidd, lvpwd) (CHECK3PAR(ivsd, lvidd, lvpwd) ? (1.04 *( pow((double)(ivsd + lvidd + lvpwd), 3.0 ) - pow((double)lvidd, 3.0) ) - 13.6) : (double)INVALID_VAL)//参数均应以cm为单位
#define ADULT_LVMASS_INDEX_F(lvmass, bsa) ((CHECK2PAR(lvmass, bsa)&&(bsa > ZERO)) ? (lvmass / bsa) : (double)INVALID_VAL)//*************//
#define ADULT_LVOT_RVOT_AREA_F(lvot_rvot_d) (CHECK1PAR(lvot_rvot_d) ? (PI * lvot_rvot_d * lvot_rvot_d / 4.0) : (double)INVALID_VAL)
#define ADULT_PVA_VMAX_F(rvotArea, rvotVmax, pvVmax) (CHECK3PAR(rvotArea, rvotVmax, pvVmax) ? (rvotArea * rvotVmax / pvVmax) : (double)INVALID_VAL)//*************//
#define ADULT_LVPW_PER_F(lvpws, lvpwd) ((CHECK2PAR(lvpwd, lvpws)&&(lvpwd > ZERO)) ? ((lvpws - lvpwd) * 100.0 / lvpwd) : (double)INVALID_VAL)
#define ADULT_PEP_ET_RATIO_F(pep, et) ((CHECK2PAR(pep, et)&&(et > ZERO)) ? (pep / et) : (double)INVALID_VAL)//*************//
#define ADULT_TIE_INDEX_F(ivrt, ivct, lvet) ((CHECK3PAR(ivrt, ivct, lvet)&&(lvet > ZERO)) ?  (ivrt + ivct) / lvet : (double)INVALID_VAL)//*************//
#define ADULT_MVA_P12T_F(mv_p12t) ((CHECK1PAR(mv_p12t)&&(fabs(mv_p12t) > ZERO)) ? (220.0 / (mv_p12t * 1000.0)) : (double)INVALID_VAL)//*************//

#define OB_AFI_F(luq, llq, ruq, rlq) (CHECK4PAR(luq, llq, ruq, rlq) ? (luq + llq + ruq + rlq) : (double)INVALID_VAL)
#define OB_MEAN_SAC_F(sac1, sac2, sac3) (CHECK3PAR(sac1, sac2, sac3) ? ((sac1 + sac2 + sac3) / 3) : (double)INVALID_VAL)
#define OB_RATIO(data1, data2) ((CHECK2PAR(data1, data2)&&(data2 > ZERO)) ? (data1 / data2) : (double)INVALID_VAL)//适合于产科的多项比例计算
#define OB_EFW_HADLOCK1_F(ac, fl) (CHECK2PAR(ac, fl) ? (pow(10 , (1.304+0.05281*ac+0.1938*fl-0.004*ac*fl))*0.001) : (double)INVALID_VAL)
#define OB_BPDA_F(bpd, ofd) (CHECK2PAR(bpd, ofd) ? sqrt(bpd * ofd * 100.0 / 1.265) : (double)INVALID_VAL)

#define FETAL_EDV_ESV_F(lvid_d_s) (CHECK1PAR(lvid_d_s) ? ((lvid_d_s * lvid_d_s * lvid_d_s * 7) / (2.4 + lvid_d_s)) : (double)INVALID_VAL)
#define FETAL_EF_F(edv, esv) ((CHECK2PAR(edv, esv)&&(edv > ZERO)) ? ((edv - esv) * 100.0 / edv) : (double)INVALID_VAL)
#define FETAL_FS_F(lvidd, lvids) ((CHECK2PAR(lvidd, lvids)&&(lvidd > ZERO)) ? ((lvidd - lvids) * 100.0 / lvidd) : (double)INVALID_VAL)
#define FETAL_SV_F(edv, esv) (CHECK2PAR(edv, esv) ? (edv - esv) : (double)INVALID_VAL)
#define FETAL_CO_F(sv, hr) (CHECK2PAR(sv, hr) ? (sv * hr) / 1000.0 : (double)INVALID_VAL)//*************//
#define FETAL_RATIO_F(data1, data2) ((CHECK2PAR(data1, data2)&&(data2 > ZERO)) ? (data1 / data2) : (double)INVALID_VAL)
#define FETAL_IVS_PER_F(ivsd, ivss) ((CHECK2PAR(ivsd, ivss)&&(ivsd > ZERO)) ? ((ivss - ivsd) * 100.0 / ivsd) : (double)INVALID_VAL)
//#define FETAL_LV_MASS //胎儿的LV Mass暂时没有公式
#define FETAL_LVETC_F(lv_et, hr_av) (CHECK2PAR(lv_et, hr_av) ? (lv_et * sqrt(hr_av/60)) : (double)INVALID_VAL)//*************//
#define FETAL_LVPEPC_F(lv_pep, hr_av) (CHECK2PAR(lv_pep, hr_av) ? ((lv_pep * 1000 + 0.4 * hr_av) / 1000.0) : (double)INVALID_VAL)//*************//
#define FETAL_LV_RV_PEPC_F(pep, hr) (CHECK2PAR(pep, hr) ? (pep + 0.4 * hr) : (double)INVALID_VAL)//*************//
//#define FETAL_LVOT_RVOT_AREA_F(lvot_rvot_d) (CHECK1PAR(lvot_rvot_d) ? (PI * lvot_rvot_d * lvot_rvot_d / 4.0 / 100.0) : (double)INVALID_VAL)   //Fetal的Lvot Area公式没有，故先屏蔽
#define FETAL_LVOT_RVOT_AREA_F(lvot_rvot_d) (double)INVALID_VAL
#define FETAL_LVPW_PER_F(lvpws, lvpwd) ((CHECK2PAR(lvpwd, lvpws)&&(lvpwd > ZERO)) ? ((lvpws - lvpwd) * 100.0 / lvpwd) : (double)INVALID_VAL)
//#define FETAL_LVETC(lvet, hr_av) (CHECK2PAR(lvet, hr_av) ? (lvet * sqrt(hr_av / 60.0)) : (double)INVALID_VAL)
#define FETAL_MEAN_VCF_F(lvidd, lvids, lvet) ((CHECK3PAR(lvidd, lvids, lvet)&&(lvidd>ZERO)&&(lvet>ZERO)) ? ((lvidd-lvids)/(lvidd*lvet)) : (double)INVALID_VAL) //Mean VCF和Mean VCFc均用此公式，Mean VCFc用LV ETc计算//*************//
#define FETAL_MEAN_VCFC_F(lvidd, lvids, lvet, hr_av) ((CHECK4PAR(lvidd, lvids, lvet, hr_av)&&(lvidd>ZERO)&&(lvet>ZERO)&&(hr_av>ZERO)) ? ((lvidd-lvids)/(lvidd*(lvet * sqrt(hr_av / 60.0)))) : (double)INVALID_VAL) //Mean VCF和Mean VCFc均用此公式，Mean VCFc用LV ETc计算//*************//
#define FETAL_RVPEPC_F(rv_pep, hr_pv) (CHECK2PAR(rv_pep, hr_pv) ? ((rv_pep * 1000 + 0.4 * hr_pv) / 1000.0) : (double)INVALID_VAL)//*************//
#define FETAL_LVMASS_CUBED_F(ivsd, lvidd, lvpwd) (CHECK3PAR(ivsd, lvidd, lvpwd) ? (0.8 * 1.04 *( pow((double)(ivsd + lvidd + lvpwd), 3.0 ) - pow((double)lvidd, 3.0) ) + 0.6) : (double)INVALID_VAL)//参数均应以cm为单位

#ifdef VET //Vet: Tendon Area Ratio
#define TENDON_AREA_RATIO(area, area1, area2, area3) ((CHECK4PAR(area, area1, area2, area3)&&(area > ZERO)) ? ((area1 + area2 + area3) / area) : (double)INVALID_VAL)
#endif

/* 函数功能：从存储测量值的数组中获取参与计算的测量值
 * 返回值：MEA_SUCCESS, MEA_FAIL, MEA_ERROR
 * currvalue：传入在测量中，本测量项的当前值
 * allItem[]：各测量值的枚举号，如果是测量中，第一个位置存储当前测量项的枚举号
 * value[]：存放要获取的各个测量值，测量值的存储位置要和allItem中的枚举号一一对应
 * itemNum：传入测量项的个数
 * state：IN_MEASURE－测量中，IN_REPORT－报告中
 * */
int MeaCalcFun::CalcGetPar(CalcInfoTmp *calcInfo, const double currValue[], double value[][MEA_MULTI], const int currItem, const int parPosi, const int state)
{
    int i, j;
    int sign;
    int noError = 0;
    int section;
    double calcResult;

    if (state == IN_MEASURE)//测量中
    {
        for(i=0; i<CALC_PAR_NUMS; i++)
        {
            if (((calcInfo->pars)[i] >= CALC_START) && ((calcInfo->pars)[i] < CALC_END))//本参数是计算值
            {
                if (currItem == (calcInfo->pars)[i])
                {
                    value[i][0] = currValue[parPosi];
                    noError++;
                }
                else
                {
                    sign = m_ptrMeaResult->ItemLabelCalc((calcInfo->pars)[i], &section);
                    if (sign != MEA_SUCCESS) return sign;
                    sign = m_ptrMeaResult->CalcGetLastValue(&calcResult, (calcInfo->pars)[i], section);
                    if (sign != MEA_SUCCESS) return sign;
                    value[i][0] = calcResult;
                    for (j=1; j<MEA_MULTI; j++) value[i][j] = INVALID_VAL;
                }
            }
            else//本参数是测量值
            {
                if (currItem == (calcInfo->pars)[i])
                {
                    for(j=0; j<MEA_MULTI; j++) value[i][j] = currValue[j];
                    noError++;
                }
                else
                {
                    if ((calcInfo->pars)[i] != NO_PAR )
                    {
                        sign = m_ptrMeaResult->GetValue((calcInfo->pars)[i], value[i], NULL, state);
                        if (sign == MEA_FAIL) {for (j=0; j<MEA_MULTI; j++) value[i][j] = INVALID_VAL;}
                        if (sign == MEA_ERROR) return sign;
                    }
                    else
                    {
                        for (j=0; j<MEA_MULTI; j++) value[i][j] = INVALID_VAL;
                    }
                }
            }
        }
        if (noError != 1) return MEA_ERROR;//allItem中没有和currItem相等或有多次相等的，说明编程时枚举号参数弄错了
    }
    else if (state == IN_REPORT_MEAN)
    {
        double valueTmp;
        for(i=0; i<CALC_PAR_NUMS; i++)
        {
            if ((calcInfo->pars)[i] != NO_PAR )
            {
                if (((calcInfo->pars)[i] >= CALC_START) && ((calcInfo->pars)[i] < CALC_END))//本参数是计算值
                {
                    sign = m_ptrMeaResult->ItemLabelCalc((calcInfo->pars)[i], &section);
                    if (sign != MEA_SUCCESS) return sign;

                    sign = m_ptrMeaResult->CalcGetValue(&valueTmp, (calcInfo->pars)[i], section);
                    if (sign != MEA_SUCCESS) return sign;
                    value[i][0] = valueTmp;
                }
                else//本参数是测量值
                {
                    sign = m_ptrMeaResult->GetValue((calcInfo->pars)[i], *(value+i), NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
            }
            else
            {
                for (j=0; j<MEA_MULTI; j++) (*(value+i))[j] = INVALID_VAL;
            }
        }
    }

    return MEA_SUCCESS;
}

/*
 *calcPosi: 本次计算出来的值放在data[]的什么地方
 * */
int MeaCalcFun::SectionCalc(CalcInfoTmp *calcInfo, double data[], int item, int save, int *calcPosi, const int parPosi)
{
    double value[CALC_PAR_NUMS][MEA_MULTI];
    int sign;
    int i, j;
    double calcResult[CALC_RESULT_CLASSES];
    CalcInfoTmp HLevelInfo;
    int section;
    double calcData[MEA_SINGLE];
    int resultPosi;

    m_ptrMeaResult = MeaResult::GetInstance();

    for (i=0; i<CALC_RESULT_CLASSES; i++)
        calcResult[i] = INVALID_VAL;

    resultPosi = *calcPosi;//本计算结果存放的位置
    (*calcPosi)++;//在测量结束时自动把计算结果存放位置移后一个

    int state;
    state = IN_MEASURE;
    sign = CalcGetPar(calcInfo, data, value, item, parPosi, state);
    if (sign == MEA_SUCCESS)
        calcResult[0] = CalcFormula(calcInfo, value);
    else
        calcResult[0] = INVALID_VAL;

    if (save == SAVE)//在测量结束存储数据时，把平均值计算结果也算出并一并保存
    {
        state = IN_REPORT_MEAN;
        sign = CalcGetPar(calcInfo, data, value, item, parPosi, state);
        if (sign != MEA_SUCCESS)
        {
            calcResult[1] = INVALID_VAL;
        //  return sign;
        }
        else
            calcResult[1] = CalcFormula(calcInfo, value);
    }

    calcData[0] = calcResult[0];
    data[resultPosi] = calcResult[0];

    if (save == SAVE)
    {
        sign = FindSection(item, &section);
        if (sign != MEA_SUCCESS)
        {
            return sign;
        }
        m_ptrMeaResult->CalcSetValue(calcResult, calcInfo->item, section);

        //计算前列腺体积时计算PSAD
        if (calcInfo->item == UR_PROSTATE_VOL)
            CalcPSAD();
    }

    if (calcInfo->ptrHCalcInfo != NULL)
    {
        const CalcInfoArray *hCalc;
        i = 0;
        hCalc = (CalcInfoArray *)(calcInfo->ptrHCalcInfo);
        while ((*hCalc)[i] != NULL)
        {
            HLevelInfo.item = (*hCalc)[i]->item;
            for (j=0; j<CALC_PAR_NUMS; j++)
            {
                HLevelInfo.pars[j] = (*hCalc)[i]->pars[j];
            }
            HLevelInfo.ptrHCalcInfo = (*hCalc)[i]->ptrHCalcInfo;
            SectionCalc(&HLevelInfo, data, calcInfo->item, save, calcPosi, resultPosi);//传入的参数有问题
            i++;
        }
    }

    return MEA_SUCCESS;
}

double MeaCalcFun::CalcFormula(CalcInfoTmp *calcInfo, double value[][MEA_MULTI])
{
    switch(calcInfo->item)
    {
        case ABD_GB_VOL:
        case ABD_CALC_SPLEEN_VOL:
        case ABD_PANC_VOL:
            //要检查用到的参数是不是有效数据
            return(GENERAL_VOL_F(value[0][0], value[1][0], value[2][0]));
            break;

        case ADULT_EDV_2DCUBED:
        case ADULT_ESV_2DCUBED:
        case ADULT_EDV_MMCUBED:
        case ADULT_ESV_MMCUBED:
            return(ADULT_EDV_ESV_CUBED_F(value[0][0]));
            break;

        case ADULT_EDV_2DTEICH:
        case ADULT_ESV_2DTEICH:
        case ADULT_EDV_MMTEICH:
        case ADULT_ESV_MMTEICH:
            return(ADULT_EDV_ESV_TEICH_F(value[0][0]));
            break;

        case ADULT_FS:
        case ADULT_FS_MM:
            return(ADULT_FS_F(value[0][0], value[1][0]));
            break;

    //  case ADULT_EF:
        case ADULT_EF_2DCUBED:
        case ADULT_EF_2DTEICH:
        case ADULT_EF_MMCUBED:
        case ADULT_EF_MMTEICH:
            return(ADULT_EF_F(value[0][0], value[1][0]));
            break;

        case ADULT_EF_A2C:
        case ADULT_EF_A4C:
        case ADULT_EF_AL:
            return(ADULT_EF_F(value[0][2], value[1][2]));
            break;

        case ADULT_SV_2DCUBED:
        case ADULT_SV_2DTEICH:
        case ADULT_SV_MMCUBED:
        case ADULT_SV_MMTEICH:
            return(ADULT_SV_F(value[0][0], value[1][0]));
            break;

        case ADULT_SV_A2C:
        case ADULT_SV_A4C:
        case ADULT_SV_AL:
            return(ADULT_SV_F(value[0][2], value[1][2]));
            break;

        case ADULT_SI_2DCUBED:
        case ADULT_SI_2DTEICH:
        case ADULT_SI_MMCUBED:
        case ADULT_SI_MMTEICH:
        case ADULT_SI_A2C:
        case ADULT_SI_A4C:
        case ADULT_SI_AL:
            {
                PatientInfo::Info paInfo;
                g_patientInfo.GetInfo(paInfo);
                float bsaValue;
                bsaValue = paInfo.e.BSA;
                return(ADULT_SI_F(value[0][0], bsaValue));
            }
            break;

        case ADULT_CO_2DCUBED:
        case ADULT_CO_2DTEICH:
        case ADULT_CO_MMCUBED:
        case ADULT_CO_MMTEICH:
        case ADULT_CO_A2C:
        case ADULT_CO_A4C:
        case ADULT_CO_AL:
            return(ADULT_CO_F(value[0][0], value[1][0]));
            break;

        case ADULT_CI_2DCUBED:
        case ADULT_CI_2DTEICH:
        case ADULT_CI_MMCUBED:
        case ADULT_CI_MMTEICH:
        case ADULT_CI_A2C:
        case ADULT_CI_A4C:
        case ADULT_CI_AL:
            {
                PatientInfo::Info paInfo;
                g_patientInfo.GetInfo(paInfo);
                float bsaValue;
                bsaValue = paInfo.e.BSA;
                return(ADULT_CI_F(value[0][0], bsaValue));
            }
            break;

        case ADULT_AVA_VMAX:
            return(ADULT_AVA_VMAX_F(value[0][0], value[1][0], value[2][0]));
            break;

        case ADULT_LVMASS:
            return(ADULT_LVMASS_F(value[0][0], value[1][0], value[2][0]));
            break;

        case ADULT_LVMASS_INDEX:
            {
                PatientInfo::Info paInfo;
                g_patientInfo.GetInfo(paInfo);
                float bsaValue;
                bsaValue = paInfo.e.BSA;
                return(ADULT_LVMASS_INDEX_F(value[0][0], bsaValue));
            }
            break;

        case ADULT_IVS_PER:
        case ADULT_IVS_PER_MM:
            return(ADULT_IVS_PER_F(value[0][0], value[1][0]));
            break;

        case ADULT_LVOT_AREA:
        case ADULT_RVOT_AREA:
            return(ADULT_LVOT_RVOT_AREA_F(value[0][0]));
            break;

        case ADULT_LVPW_PER:
        case ADULT_LVPW_PER_MM:
            return(ADULT_LVPW_PER_F(value[0][0], value[1][0]));
            break;

        case ADULT_IVS_LVPW_RATIO:
        case ADULT_IVS_LVPW_RATIO_MM:
        case ADULT_LA_AO_RATIO:
        case ADULT_LA_AO_RATIO_MM:
        case ADULT_LV_PEP_ET_RATIO:
        case ADULT_RV_PEP_ET_RATIO:
            return(GENERAL_RATIO_F(value[0][0], value[1][0]));
            break;

        case ADULT_MVA_P12T:
            return(ADULT_MVA_P12T_F(value[0][1]));
            break;

        case ADULT_MV_EA_RATIO:
            return(GENERAL_RATIO_F(value[0][0], value[1][0]));
            break;

        case ADULT_PVA_VMAX:
            return(ADULT_PVA_VMAX_F(value[0][0], value[1][0], value[2][0]));
            break;

        case ADULT_PULM_SD_RATIO:
            return(GENERAL_RATIO_F(value[0][0], value[1][0]));
            break;

        case ADULT_TEI_INDEX:
            return(ADULT_TIE_INDEX_F(value[0][0], value[1][0], value[2][0]));
            break;

        case ADULT_TV_AREA:
            return(GENERAL_AREA_F(value[0][0]));
            break;

        case ADULT_AI_PISA:
            return(GENERAL_PISA_F(value[0][0]));
            break;

        case ADULT_MV_PISA:
            return(GENERAL_PISA_F(value[0][0]));
            break;

        case ADULT_MR_PISA:
            return(GENERAL_PISA_F(value[0][0]));
            break;

        case ADULT_TV_PISA:
            return(GENERAL_PISA_F(value[0][0]));
            break;

        case ADULT_TV_EA_RATIO:
            return(GENERAL_RATIO_F(value[0][0], value[1][0]));
            break;

        case OB_CALC_AFI:
            //确保测量过任意AFI子菜单都可以输出AFI的值zjx
            if(value[0][0] == INVALID_VAL)
                value[0][0]=0.0;
            if(value[1][0] == INVALID_VAL)
                value[1][0]=0.0;
            if(value[2][0] == INVALID_VAL)
                value[2][0]=0.0;
            if(value[3][0] == INVALID_VAL)
                value[3][0]=0.0;
            return(OB_AFI_F(value[0][0], value[1][0], value[2][0], value[3][0]));
            break;
            /*
               case OB_MEAN_SAC:
            return(OB_MEAN_SAC_F(value[0][0], value[1][0], value[2][0]));
            break;
*/
        case OB_AO_PA_RATIO:
        case OB_HRTC_THRC_RATIO:
        case OB_LA_AO_RTAIO:
        case OB_LA_RA_RATIO:
        case OB_LV_RV_RATIO:
        case OB_HC_AC_RATIO:
        case OB_FL_BPD_RATIO:
        case OB_FL_AC_RATIO:
        case OB_CI:
            return(OB_RATIO(value[0][0], value[1][0]));
            break;

        case OB_BPDA:
            return(OB_BPDA_F(value[0][0], value[1][0]));
            break;

        case FETAL_EDV_2DTEICH:
        case FETAL_ESV_2DTEICH:
        case FETAL_EDV_MMTEICH:
        case FETAL_ESV_MMTEICH:
            return(FETAL_EDV_ESV_F(value[0][0]));
            break;

        case FETAL_EF_2DTEICH:
        case FETAL_EF_MMTEICH:
            return(FETAL_EF_F(value[0][0], value[1][0]));
            break;

        case FETAL_SV_2DTEICH:
        case FETAL_SV_MMTEICH:
            return(FETAL_SV_F(value[0][0], value[1][0]));
            break;

        case FETAL_FS_2DTEICH:
        case FETAL_FS_MMTEICH:
            return(FETAL_FS_F(value[0][0], value[1][0]));
            break;

        case FETAL_CO_2DTEICH:
        case FETAL_CO_MMTEICH:
            return(FETAL_CO_F(value[0][0], value[1][0]));
            break;

        case FETAL_IVS_PER:
        case FETAL_IVS_PER_MM:
            return(FETAL_IVS_PER_F(value[0][0], value[1][0]));
            break;

        case FETAL_LVOT_AREA:
        case FETAL_RVOT_AREA:
            return(FETAL_LVOT_RVOT_AREA_F(value[0][0]));
            break;

        case FETAL_LVPW_PER:
        case FETAL_LVPW_PER_MM:
            return(FETAL_LVPW_PER_F(value[0][0], value[1][0]));
            break;

        case FETAL_LVETC:
            return(FETAL_LVETC_F(value[0][0], value[1][0]));
            break;

        case FETAL_LVPEPC:
            return(FETAL_LVPEPC_F(value[0][0], value[1][0]));
            break;

        case FETAL_MEAN_VCF:
                return(FETAL_MEAN_VCF_F(value[0][0], value[1][0], value[2][0]));
            break;

        case FETAL_MEAN_VCFC:
            return(FETAL_MEAN_VCFC_F(value[0][0], value[1][0], value[2][0], value[3][0]));
            break;

        case FETAL_AO_PA_RATIO:
        case FETAL_HRTC_THRC_RATIO:
        case FETAL_IVS_LVPW_RATIO:
    //  case FETAL_LA_AO_RATIO:
    //  case FETAL_LA_RA_RATIO:
        case FETAL_LA_AO_RATIO_MM:
        case FETAL_LV_PEP_ET_RATIO:
        case FETAL_LV_RV_RATIO:
        case FETAL_RV_PEP_ET_RATIO:
        case FETAL_MV_EA_RATIO:
        case FETAL_TV_EA_RATIO:
        case FETAL_IVS_LVPW_MM:
            return(GENERAL_RATIO_F(value[0][0], value[1][0]));
            break;

        case FETAL_LA_AO_RATIO:
        case FETAL_LA_RA_RATIO://FETAL_LA_AO_RATIO, FETAL_LA_AO_RATIO_MM, FETAL_LA_RA_RATIO计算所使用的LA参数与成人超声和产科中对不上，不能确定胎儿超声中是否正确，故先屏蔽掉(返回无效值)
            return INVALID_VAL;
            break;

        case FETAL_RVPEPC:
            return(FETAL_RVPEPC_F(value[0][0], value[1][0]));
            break;

        case FETAL_LV_MASS:
        //  return(FETAL_LVMASS_CUBED_F(value[0][0], value[1][0], value[2][0]));//胎儿超声的LV Mass公式还没有，故先屏蔽掉
            return((double)INVALID_VAL);
            break;

        case GYN_CALC_BLADDER_VOL:
        case GYN_CALC_PV_BLADDER_VOL:
        case GYN_CALC_L_OV_VOL:
        case GYN_CALC_R_OV_VOL:
        case OB_CALC_L_OV_VOL:
        case OB_CALC_R_OV_VOL:
        case GYN_CALC_UTERUS_VOL:
            return(GENERAL_VOL_F(value[0][0], value[1][0], value[2][0]));
            break;

        case GYN_L_FOLL1_VOL:
        case GYN_L_FOLL2_VOL:
        case GYN_L_FOLL3_VOL:
        case GYN_L_FOLL4_VOL:
        case GYN_L_FOLL5_VOL:
        case GYN_L_FOLL6_VOL:
        case GYN_L_FOLL7_VOL:
        case GYN_L_FOLL8_VOL:
        case GYN_L_FOLL9_VOL:
        case GYN_L_FOLL10_VOL:
        case GYN_R_FOLL1_VOL:
        case GYN_R_FOLL2_VOL:
        case GYN_R_FOLL3_VOL:
        case GYN_R_FOLL4_VOL:
        case GYN_R_FOLL5_VOL:
        case GYN_R_FOLL6_VOL:
        case GYN_R_FOLL7_VOL:
        case GYN_R_FOLL8_VOL:
        case GYN_R_FOLL9_VOL:
        case GYN_R_FOLL10_VOL:
/*      case GYN_FIBROID1_VOL:
        case GYN_FIBROID2_VOL:
        case GYN_FIBROID3_VOL:
        case GYN_FIBROID4_VOL:
        case GYN_FIBROID5_VOL:
        case GYN_FIBROID6_VOL:
        case GYN_FIBROID7_VOL:
        case GYN_FIBROID8_VOL:
        case GYN_FIBROID9_VOL:
        case GYN_FIBROID10_VOL:
*/
            return(PELLET_VOL_F(value[0][0]));
            break;

        case UR_CALC_BLADDER_VOL:
        case UR_CALC_PV_BLADDER_VOL:
        case UR_CALC_PROSTATE_VOL:
        case UR_CALC_L_KID_VOL:
        case UR_CALC_R_KID_VOL:
            return(GENERAL_VOL_F(value[0][0], value[1][0], value[2][0]));
            break;

        case SP_L_TESTIS_VOL_C:
        case SP_R_TESTIS_VOL_C:
            return(GENERAL_VOL_F(value[0][0], value[1][0], value[2][0]));
            break;
#ifdef VET
#else
        case SP_BRE_L_LESION1_VOL_C:
        case SP_BRE_L_LESION2_VOL_C:
        case SP_BRE_L_LESION3_VOL_C:
        case SP_BRE_L_LESION4_VOL_C:
        case SP_BRE_L_LESION5_VOL_C:
        case SP_BRE_R_LESION1_VOL_C:
        case SP_BRE_R_LESION2_VOL_C:
        case SP_BRE_R_LESION3_VOL_C:
        case SP_BRE_R_LESION4_VOL_C:
        case SP_BRE_R_LESION5_VOL_C:
            return(GENERAL_VOL_F(value[0][0], value[1][0], value[2][0]));
            break;
#endif
#ifdef VET
        case SP_BRE1_LESION1_VOL_C:
        case SP_BRE1_LESION2_VOL_C:
        case SP_BRE1_LESION3_VOL_C:
        case SP_BRE1_LESION4_VOL_C:
        case SP_BRE1_LESION5_VOL_C:
        case SP_BRE2_LESION1_VOL_C:
        case SP_BRE2_LESION2_VOL_C:
        case SP_BRE2_LESION3_VOL_C:
        case SP_BRE2_LESION4_VOL_C:
        case SP_BRE2_LESION5_VOL_C:
        case SP_BRE3_LESION1_VOL_C:
        case SP_BRE3_LESION2_VOL_C:
        case SP_BRE3_LESION3_VOL_C:
        case SP_BRE3_LESION4_VOL_C:
        case SP_BRE3_LESION5_VOL_C:
        case SP_BRE4_LESION1_VOL_C:
        case SP_BRE4_LESION2_VOL_C:
        case SP_BRE4_LESION3_VOL_C:
        case SP_BRE4_LESION4_VOL_C:
        case SP_BRE4_LESION5_VOL_C:
        case SP_BRE5_LESION1_VOL_C:
        case SP_BRE5_LESION2_VOL_C:
        case SP_BRE5_LESION3_VOL_C:
        case SP_BRE5_LESION4_VOL_C:
        case SP_BRE5_LESION5_VOL_C:
            return(GENERAL_VOL_F(value[0][0], value[1][0], value[2][0]));
            break;
#endif

        case SP_TES_L_LESION1_VOL_C:
        case SP_TES_L_LESION2_VOL_C:
        case SP_TES_L_LESION3_VOL_C:
        case SP_TES_L_LESION4_VOL_C:
        case SP_TES_L_LESION5_VOL_C:
        case SP_TES_R_LESION1_VOL_C:
        case SP_TES_R_LESION2_VOL_C:
        case SP_TES_R_LESION3_VOL_C:
        case SP_TES_R_LESION4_VOL_C:
        case SP_TES_R_LESION5_VOL_C:
        case SP_THY_LESION1_VOL_C:
        case SP_THY_LESION2_VOL_C:
        case SP_THY_LESION3_VOL_C:
        case SP_THY_LESION4_VOL_C:
        case SP_THY_LESION5_VOL_C:
            return(GENERAL_VOL_F(value[0][0], value[1][0], value[2][0]));
            break;

        case VS_L_ICA_CCA_RATIO:
        case VS_R_ICA_CCA_RATIO:
    //      printf("()()...()in VS: value[0]= %f, value[1]= %f\n", value[0][0], value[1][0]);
            return(GENERAL_RATIO_F(value[0][0], value[1][0]));
            break;
#ifdef VET
                        /*
        case TEN_AREA_RATIO1:
        case TEN_AREA_RATIO2:
        case TEN_AREA_RATIO3:
        case TEN_AREA_RATIO4:
        case TEN_AREA_RATIO5:
        case TEN_AREA_RATIO6:
        case TEN_AREA_RATIO7:
        case TEN_AREA_RATIO8:
        case TEN_AREA_RATIO9:
        case TEN_AREA_RATIO10:
        case TEN_AREA_RATIO11:
            return(TENDON_AREA_RATIO(value[0][0], value[1][0], value[2][0], value[3][0]));
                        */
#endif
        default:
            break;
    }

    return (double)INVALID_VAL;
}

int MeaCalcFun::FindSection(int item, int *section)
{
    int sign;

    sign = m_ptrMeaResult->ItemLabel(item, NULL, NULL, NULL, NULL, NULL, section);

/*  if (sign != MEA_SUCCESS)
        sign = m_ptrMeaResult->ItemLabelMulti(item, &itemTmp, &ptrResultMulti, &volume, section);
    else
        return MEA_SUCCESS;

    if (sign != MEA_SUCCESS)
        sign = m_ptrMeaResult->ItemLabelSingle(item, &itemTmp, &ptrResultSingle, &volume, section);
    else
        return MEA_SUCCESS;
*/
    if (sign != MEA_SUCCESS) //不是测量项的枚举号
        sign = m_ptrMeaResult->ItemLabelCalc(item, section);
    else
        return MEA_SUCCESS;

    return sign;
}

/*
 *计算自定义产科表的胎龄
 * */
int MeaCalcFun::CalcGWUser(const double data, int *gw, const int obTable[])
{
    int value;
    int dayBefore, dayAfter;
    float tableStart, tableEnd;
    int tableLen = 0;

    tableLen = 270;
    tableStart = obTable[270];
    tableEnd = obTable[271];
    value = (int)(data * 100);//自定义表存储的数据都是在mm的基础上放大了10倍，而距离是以cm为单位
    //value = (int)(data * 100 * k);//自定义表存储的数据都是在mm的基础上放大了10倍，而距离是以cm为单位,面积是以cm2为单位，因此如果data为距离数据，需放大10*10，若data为面积数据，需放大10*100倍

    if((value>=tableStart) && (value<=tableEnd))
    {
        for ( dayAfter= 0; dayAfter < tableLen; dayAfter++ )///////////////////
        {
            if (obTable[dayAfter] >= value)
                break;
        }

        for (dayBefore=dayAfter; dayBefore>=0; dayBefore--)
        {
            if (obTable[dayBefore] == 0)
                continue;
            if (obTable[dayBefore] <= value)
                break;
        }

        if ((dayBefore == 0) && (obTable[0] == 0))
            return MEA_FAIL;
        if (obTable[dayAfter] == obTable[dayBefore])
            *gw = (dayBefore + dayAfter) / 2;
        else
            *gw = dayBefore + ((double)(value - obTable[dayBefore]) / (double)(obTable[dayAfter] - obTable[dayBefore])) * (float)(dayAfter - dayBefore);
        *gw = *gw + USER_TABLE_START;
    }
    else
        return MEA_FAIL;

    return MEA_SUCCESS;
}

int MeaCalcFun::CalcGWUser(const double data, int *gw, const int obTable[],int k)
{
    int value;
    int dayBefore, dayAfter;
    float tableStart, tableEnd;
    int tableLen = 0;

    tableLen = 270;
    tableStart = obTable[270];
    tableEnd = obTable[271];
    value = (int)(data * 100 * k);//自定义表存储的数据都是在mm的基础上放大了10倍，而距离是以cm为单位,面积是以cm2为单位，因此如果data为距离数据，需放大10*10，若data为面积数据，需放大10*100倍

    if((value>=tableStart) && (value<=tableEnd))
    {
        for ( dayAfter= 0; dayAfter < tableLen; dayAfter++ )///////////////////
        {
            if (obTable[dayAfter] >= value)
                break;
        }

        for (dayBefore=dayAfter; dayBefore>=0; dayBefore--)
        {
            if (obTable[dayBefore] == 0)
                continue;
            if (obTable[dayBefore] <= value)
                break;
        }

        if ((dayBefore == 0) && (obTable[0] == 0))
            return MEA_FAIL;
        if (obTable[dayAfter] == obTable[dayBefore])
            *gw = (dayBefore + dayAfter) / 2;
        else
            *gw = dayBefore + ((double)(value - obTable[dayBefore]) / (double)(obTable[dayAfter] - obTable[dayBefore])) * (float)(dayAfter - dayBefore);
        *gw = *gw + USER_TABLE_START;
    }
    else
        return MEA_FAIL;

    return MEA_SUCCESS;
}

int MeaCalcFun::CalcPSAD(void)
{
    double prostateVol;
    double spsa;
    double psad;

    PatientInfo::Info info;
    g_patientInfo.GetInfo(info);

    if(info.uro.PSA == -1)
        return MEA_FAIL;
    else
        spsa = info.uro.PSA;

    m_ptrMeaResult = MeaResult::GetInstance();
//  m_ptrMeaResult->CalcGetSPSA(spsa, psad);
    m_ptrMeaResult->CalcGetValue(&prostateVol, UR_PROSTATE_VOL, UR_M);
    if (prostateVol > ZERO)
        psad = spsa / prostateVol;
    else
    {
        psad = (double)INVALID_VAL;
        return MEA_FAIL;
    }

    m_ptrMeaResult->CalcSetSPSA(spsa);
    m_ptrMeaResult->CalcSetPSAD(psad);
    return MEA_SUCCESS;
}

int MeaCalcFun::CalcGW_Ovul(unsigned int LMP_Y, unsigned int LMP_M, unsigned int LMP_D)
{
    int gw;
    gw = CalcGW_LMP(LMP_Y, LMP_M, LMP_D);
    if (gw <= 0)
        return 0;
    else
        return(gw + 14);
}
/*
 * @brief: calculate GW by LMP date
 * @retval GW value
 */
int MeaCalcFun::CalcGW_LMP(unsigned int LMP_Y, unsigned int LMP_M, unsigned int LMP_D)
{
    int year, month, day;
    int LMPgw = 0; // in days
    int LMPGW = 0;
    int i;
    unsigned char monthdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    GetCurrentDate(year, month, day);

    if( LMP_Y!=0 && LMP_M!=0 && LMP_D!=0 )
    {
        if ((year-LMP_Y)>1) { LMPGW=0; return 0;}

        if( !(LMP_Y% 4 ) )  monthdays[1] = 29;
        if (year > (int)LMP_Y)
        {
            for (i=LMP_M; i<=12; i++)
            {
                LMPgw += monthdays[i-1];
            }
            LMPgw = LMPgw-LMP_D+1;

            if( !(year% 4 ) )  monthdays[1] = 29;
            else monthdays[1] = 28;

            for (i=1; i<month; i++)
            {
                LMPgw += monthdays[i-1];
            }
            LMPgw += day;
        }
        else
        {
            if ((month>(int)LMP_M) || (day>(int)LMP_D))
            {
                for (i=LMP_M; i<month; i++)
                {
                    LMPgw += monthdays[i-1];
                }
                LMPgw = LMPgw-LMP_D+1+day;
            }
            else
            {
                return 0;
            }
        }
        LMPGW = LMPgw;
    }
    return LMPGW;
}

void MeaCalcFun::CalcEDCB_Ovul(unsigned int LMP_Y, unsigned int LMP_M, unsigned int LMP_D, char* retval)
{
    CalcEDCB(LMP_Y, LMP_M, LMP_D, HumanDOP_Ovul, retval);
}

void MeaCalcFun::CalcEDCB_LMP(unsigned int LMP_Y, unsigned int LMP_M, unsigned int LMP_D, char* retval)
{
    CalcEDCB(LMP_Y, LMP_M, LMP_D, HumanDOP, retval);
}

/*
 * @brief: calculate EDCB by LMP date
 */
void MeaCalcFun::CalcEDCB(unsigned int start_year, unsigned int start_month, unsigned int start_day, int dop, char* retval)
{
    if(retval==NULL)
        return;

    unsigned int dayleft, year, month;
    unsigned char monthdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    SysGeneralSetting sys;
    int dateFormat= sys.GetDateFormat();

    year = start_year;
    month = start_month;
    dayleft = dop;

    if (!( start_year% 4 ))
        monthdays[1] = 29;
    else
        monthdays[1] = 28;
    if (start_year>0 && start_month>0 && start_month<=12 && start_day>0 && start_day<=monthdays[start_month-1])
    {
        if (dayleft > (monthdays[month-1]-start_day))
        {
            dayleft -= monthdays[month-1]-start_day;
            month++;
            if (month == 13)
            {
                month = 1;
                year++;
                if (!(year % 4))
                    monthdays[1] = 29;
                else
                    monthdays[1] = 28;
            }
            while(dayleft > monthdays[month-1])
            {
                dayleft-=monthdays[month-1];
                month++;
                if(month==13)
                {
                    month=1;
                    year++;
                    if(!(year % 4))
                        monthdays[1]=29;
                    else
                        monthdays[1]=28;
                }
            }
            if(dateFormat == 1)
                sprintf(retval, "%02d/%02d/%02d", month, dayleft, year);//mon-day-year
            else if(dateFormat == 2)
                sprintf(retval, "%02d/%02d/%02d", dayleft, month, year);//day-mon-year
            else
                sprintf(retval, "%02d/%02d/%02d", year, month, dayleft);//year-mon-day
        }
        else
        {
            if(dateFormat == 1)
                sprintf(retval, "%02d/%02d/%02d", month, (start_day + dayleft), year);//mon-day-year
            else if(dateFormat == 2)
                sprintf(retval, "%02d/%02d/%02d", (start_day + dayleft), month, year);//day-mon-year
            else
                sprintf(retval, "%02d/%02d/%02d", year, month, (start_day + dayleft));//year-mon-day
        }
    }
}

/*
 *multipe: 产科表数据相对于实际数据的倍率，大多数产科表数据乘以了10倍
 * */
int MeaCalcFun::CalcGW(const double data, int *gw, const int obTable[])
{
    int day = 0;
    float value;
    float tableStart, tableEnd;
    int tableLen = 0;
    int multiple;
    int startDay;

    tableLen = obTable[0];//产科表长度
    multiple = obTable[1];//产科表数据相对毫米的放大倍数
    startDay = obTable[2];//产科表数据的起始时间

    tableStart = (double)obTable[GW_TABLE_HEAD_LEN];
    tableEnd = (double)obTable[tableLen + GW_TABLE_HEAD_LEN - 1];
    value = data * multiple * 10.0;//距离测量是以厘米为单位

    if((value>=tableStart) && (value<=tableEnd))
    {
        for ( day= 0; day < tableLen; day++ )///////////////////
        {
            if(obTable[ day + GW_TABLE_HEAD_LEN ] >= value)
                break;
        }

        if ( (value- obTable[day + GW_TABLE_HEAD_LEN - 1]) < (obTable[day + GW_TABLE_HEAD_LEN] - value))
            day--;
    }
    else
        return MEA_FAIL;

    *gw = day + startDay;

    return MEA_SUCCESS;
}

int MeaCalcFun::CalcGW(const double data, int *gw, const int obTable[],int k)
{
    int day = 0;
    double value;
    double tableStart, tableEnd;
    int tableLen = 0;
    int multiple;
    int startDay;

    tableLen = obTable[0];//产科表长度
    multiple = obTable[1];//产科表数据相对毫米的放大倍数
    startDay = obTable[2];//产科表数据的起始时间

    tableStart = (double)obTable[GW_TABLE_HEAD_LEN];
    tableEnd = (double)obTable[tableLen + GW_TABLE_HEAD_LEN - 1];
    value = data * multiple * 10.0 * k;//距离测量是以厘米为单位

    if((value>=tableStart) && (value<=tableEnd))
    {
        for ( day= 0; day < tableLen; day++ )///////////////////
        {
            if(obTable[ day + GW_TABLE_HEAD_LEN ] >= value)
                break;
        }

        if ( (value- obTable[day + GW_TABLE_HEAD_LEN - 1]) < (obTable[day + GW_TABLE_HEAD_LEN] - value))
            day--;
    }
    else
        return MEA_FAIL;

    *gw = day + startDay;

    return MEA_SUCCESS;
}
#ifdef VET
/*
 *function:计算Vet的胎龄
 * */
int MeaCalcFun::CalcGWVet(const double data, int *gw, const int obTable[][2])
{
    int day = 0;
    double value;
//  int tableLen = 0;
    int multiple;
    int i = 1;

    multiple = obTable[0][0];
    value = data * multiple *10.0;

    while (value > obTable[i][0])
    {
        i++;
        if (obTable[i][0] == 0)
            return MEA_FAIL;
    }

    if(value < obTable[0][0])
        return MEA_FAIL;

    if (obTable[i][0] == value)
        day = obTable[i][1];
    else
        day =(int)( (double)obTable[i-1][1] + ((double)(value-obTable[i-1][0])/(double)(obTable[i][0]-obTable[i-1][0]))*(double)(obTable[i][1]-obTable[i-1][1]) + 0.5 );

    *gw = day;
    return MEA_SUCCESS;
}
#endif
void MeaCalcFun::CalcAGW(void)
{
    int i;
    double gwValue;
    double sumLast = 0.0;
    double sumMean = 0.0;
    double avgGw[2][CALC_RESULT_CLASSES];
    int countLast = 0, countMean = 0;

    m_ptrMeaResult = MeaResult::GetInstance();

    for (i=0; i<OB_CALC_END - OB_CALC_START; i++)
    {
        gwValue = (double)INVALID_VAL;
        if (strcmp(OBCalcInfoPtr[i].ptrCalcInfo->title, "GW") != 0)
            continue;
        if (m_ptrMeaResult->CalcGetLastValue(&gwValue, i+OB_CALC_START, OB_M) != MEA_SUCCESS)
            goto Avg;
        if (((int)gwValue <= HumanDOP) && (gwValue > ZERO))
        {
            sumLast += gwValue;
            countLast++;
        }

    Avg:
        if (m_ptrMeaResult->CalcGetMeanValue(&gwValue, i+OB_CALC_START, OB_M) != MEA_SUCCESS)
            continue;
        if (((int)gwValue <= HumanDOP) && (gwValue > ZERO))
        {
            sumMean += gwValue;
            countMean++;
        }
    }

    int edcb;
    if (countLast != 0)
    {
        avgGw[0][0] = sumLast / countLast;//最后值孕周的平均孕周
        if (EDCBFormula(HumanDOP, (int)avgGw[0][0], &edcb) == MEA_SUCCESS)
            avgGw[1][0] = (double)edcb;
        else
            avgGw[1][0] =  (double)INVALID_VAL;
    }
    else
    {
        avgGw[0][0] = (double)INVALID_VAL;
        avgGw[1][0] = (double)INVALID_VAL;
    }

    if (countMean != 0)
    {
        avgGw[0][1] = sumMean / countMean;//平均值孕周的平均孕周
        if (EDCBFormula(HumanDOP, avgGw[0][1], &edcb) == MEA_SUCCESS)
            avgGw[1][1] = (double)edcb;
        else
            avgGw[1][1] =  (double)INVALID_VAL;
    }
    else
    {
        avgGw[0][1] = (double)INVALID_VAL;
        avgGw[1][1] = (double)INVALID_VAL;
    }

    m_ptrMeaResult->CalcSetAgwValue(avgGw);
}

#if 1
int MeaCalcFun::CalcGWMan(CalcInfoTmp *calcInfo, double data[], int item, int save, int *position, const int parPosi)
{
    double normValue;
    double value[MEA_MULTI];
    int gw = 0;
    int sign;
    double calcResult[CALC_RESULT_CLASSES];
//  CalcInfoTmp HLevelInfo;
    int i;

    m_ptrMeaResult = MeaResult::GetInstance();

    for (i=0; i<CALC_RESULT_CLASSES; i++)
        calcResult[i] = INVALID_VAL;

    (*position)++;//在测量结束时自动把计算结果存放位置移后一个

    normValue = data[parPosi];
    const int method = GetGWMethod(item);//传入item, 返回EOBGwMethod值

    switch(method + 1)
    {
        case CER_USER:
        case HL_USER:
        case BPD_USER:
        case FL_USER:
        case CRL_USER:
        case GS_USER:
        case AC_USER:
        case HC_USER:
        case TAD_USER:
        case APAD_USER:
        case THD_USER:
        case OFD_USER:
        case OOD_USER:
        case TIBIA_USER:
        case TTD_USER:
        case ULNA_USER:
             sign = CalcGWUser(normValue, &gw, GWMethodLine[method],1);
             break;
        case FTA_USER:
        //  sign = CalcGWUser(normValue, &gw, GWMethodLine[method]);
            sign = CalcGWUser(normValue, &gw, GWMethodLine[method],100);
            break;
        case FTA_START:
            sign = CalcGW(normValue, &gw, GWMethodLine[method],10);
            break;

        default:
            sign = CalcGW(normValue, &gw, GWMethodLine[method],1);
            break;
    }
    if (sign != MEA_SUCCESS) gw = INVALID_VAL_GW;
    data[MEA_SINGLE] = (double)gw;
    calcResult[0] = (double)gw;

    if(save == SAVE)//在测量结束时，计算平均值的计算结果并一并保存
    {
        sign = m_ptrMeaResult->GetValue(item, value, NULL, IN_AVERAGE);
        if (sign != MEA_SUCCESS) goto save;//return sign;
        normValue = value[0];

        switch(method + 1)
        {
            case CER_USER:
            case HL_USER:
            case BPD_USER:
            case FL_USER:
            case CRL_USER:
            case GS_USER:
            case AC_USER:
            case HC_USER:
            case TAD_USER:
            case APAD_USER:
            case THD_USER:
            case OFD_USER:
            case OOD_USER:
            case TIBIA_USER:
            case TTD_USER:
            case ULNA_USER:
                sign = CalcGWUser(normValue, &gw, GWMethodLine[method],1);
                break;
            case FTA_USER:
                sign = CalcGWUser(normValue, &gw, GWMethodLine[method],10);
                break;
            case FTA_START:
                sign = CalcGW(normValue, &gw, GWMethodLine[method],10);
                break;

            default:
                sign = CalcGW(normValue, &gw, GWMethodLine[method],1);
                break;
        }
        if (sign != MEA_SUCCESS)
            gw = INVALID_VAL;

        save:
        calcResult[1] = (double)gw;
        m_ptrMeaResult->CalcSetValue(calcResult, calcInfo->item, OB_M);

        CalcAGW();
    }

    return MEA_SUCCESS;
}
#endif

#ifdef VET
int MeaCalcFun::CalcGWManVet(CalcInfoTmp *calcInfo, double data[], int item, int save, int *position, const int parPosi)
{
    double normValue;
    double value[MEA_MULTI];
    int gw = 0;
    int sign;
    double calcResult[CALC_RESULT_CLASSES];
//  CalcInfoTmp HLevelInfo;
    int i;

    m_ptrMeaResult = MeaResult::GetInstance();

    for (i=0; i<CALC_RESULT_CLASSES; i++)
        calcResult[i] = INVALID_VAL;

    (*position)++;//在测量结束时自动把计算结果存放位置移后一个

    normValue = data[parPosi];
    //Vet不需要选方法
//  const int method = GWMethod.GetGWMethod(item);//传入item, 返回EOBGwMethod值

/*Vet中先未加自定义，故先屏蔽，后面加时再开放
    switch(method + 1)
    {
        case CER_USER:
        case HL_USER:
        case BPD_USER:
        case FL_USER:
        case CRL_USER:
        case GS_USER:
        case AC_USER:
        case HC_USER:
        case TAD_USER:
        case APAD_USER:
        case THD_USER:
        case OFD_USER:
        case OOD_USER:
        case TIBIA_USER:
        case TTD_USER:
        case ULNA_USER:
            sign = CalcGWUser(normValue, &gw, GWMethodLine[method]);
            break;

        default:
            sign = CalcGW(normValue, &gw, GWMethodLine[method]);
            break;
    }
*/
    int method = 0;
//hlx
//  method = item - OB_MEA_VET_START;
    method = item - ANOB_MEA_START;

    sign = CalcGWVet(normValue, &gw, GWMethodLineVet[method]);

    if (sign != MEA_SUCCESS) return sign;
    data[MEA_SINGLE] = (double)gw;
    calcResult[0] = (double)gw;

    if(save == SAVE)//在测量结束时，计算平均值的计算结果并一并保存
    {
        sign = m_ptrMeaResult->GetValue(item, value, NULL, IN_MEASURE);
        if (sign != MEA_SUCCESS) goto save;//return sign;
        normValue = value[0];
    //hlx
    //  sign = CalcGW(normValue, &gw, GWMethodLine[method]);
        sign = CalcGWVet(normValue, &gw, GWMethodLineVet[method]);
        if (sign != MEA_SUCCESS) return sign;

    save:
        calcResult[1] = (double)gw;
    //hlx
    //  m_ptrMeaResult->CalcSetValue(calcResult, calcInfo->item, OB_M);
        m_ptrMeaResult->CalcSetValue(calcResult, calcInfo->item, ANOB_M);
    }

/*
    if (calcInfo->ptrHCalcInfo == NULL)
        goto end;
    CalcResultInfo *ptrEDCB;
    ptrEDCB = (CalcResultInfo*)(calcInfo->ptrHCalcInfo);
    HLevelInfo.item = ptrEDCB->item;
    for (j=0; j<CALC_PAR_NUMS; j++)
    {
        HLevelInfo.pars[j] = ptrEDCB->pars[j];
    }
    HLevelInfo.ptrHCalcInfo = ptrEDCB->ptrHCalcInfo;
    EDCBCalc(&HLevelInfo, data, calcInfo->item, save, position+1);

end:
*/
    return MEA_SUCCESS;
}
#endif
#if 0   //人用备份
//void CalculateEDCB(int daypast, unsigned char resultline, unsigned char year1, unsigned char mon1, unsigned char date1)
int MeaCalcFun::EDCBCalc(CalcInfoTmp *calcInfo, float data[], int item, int save, int position)
{
    unsigned int key;
    int dayleft, fast;
    unsigned char year, mon, date, yearflow;
    unsigned char monthdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    int daypast;
    float gw;
    float calcResult[CALC_RESULT_CLASSES];
    int i;

    for (i=0; i<CALC_RESULT_CLASSES; i++)
        calcResult[i] = INVALID_VAL;

    daypast = (int)data[MEA_SINGLE];
    if (daypast == INVALID_VAL)
        return MEA_FAIL;

    time_t now;
    struct tm* ct;

    time(&now);
    ct = localtime(&now);

    year = (ct->tm_year + 1900) % 100;
    mon = ct->tm_mon + 1;
    date = ct->tm_mday;

    if( daypast < 280 )
    {
        if( !( year  % 4 ) )  monthdays[1] = 29;

        dayleft = 280 - daypast;

        yearflow = 0;
        key = mon;
        fast = monthdays[ key - 1 ] - date;

        if( dayleft < fast )
        {
            data[MEA_SINGLE+1] = (double)(year*10000 + key*100 + (date+dayleft));
            calcResult[0] = (double)data[MEA_SINGLE+1];
        }
        else
        {
            dayleft -= fast;
            key++;

            if (key==13)
            {
                yearflow = 1;
                key = 1;
                if( !( (year + 1 ) % 4 ) )  monthdays[1] = 29;
                    else monthdays[1] = 28;
            }

            while( dayleft > monthdays[ key - 1 ] )
            {
                dayleft -= monthdays[ key - 1 ];
                if( ++key > 12 )
                {
                    yearflow = 1;
                    key = 1;
                    if( !( (year + 1 ) % 4 ) )  monthdays[1] = 29;
                    else monthdays[1] = 28;
                }
            }

            date = dayleft;

            year += yearflow;
            if (year > 99) year = year - 100;

            data[MEA_SINGLE+1] = (double)(year*10000 + key*100 + date);
            calcResult[0] = (double)data[MEA_SINGLE+1];
        }
    }
    else
    {
        return MEA_FAIL;
    }

    if (save == SAVE)
    {
        m_ptrMeaResult->CalcGetMeanValue(&gw, item, OB_M);
        daypast = (int)gw;

        if( daypast < 280 )
        {
            if( !( year  % 4 ) )  monthdays[1] = 29;

            dayleft = 280 - daypast;

            yearflow = 0;
            key = mon;
            fast = monthdays[ key - 1 ] - date;

            if( dayleft < fast )
            {
                calcResult[1] = (double)(year*10000 + key*100 + (date+dayleft));
            }
            else
            {
                dayleft -= fast;
                key++;

                if (key==13)
                {
                    yearflow = 1;
                    key = 1;
                    if( !( (year + 1 ) % 4 ) )  monthdays[1] = 29;
                    else monthdays[1] = 28;
                }

                while( dayleft > monthdays[ key - 1 ] )
                {
                    dayleft -= monthdays[ key - 1 ];
                    if( ++key > 12 )
                    {
                        yearflow = 1;
                        key = 1;
                        if( !( (year + 1 ) % 4 ) )  monthdays[1] = 29;
                        else monthdays[1] = 28;
                    }
                }

                date = dayleft;

                year += yearflow;
                if (year > 99) year = year - 100;

                calcResult[1] = (double)(year*10000 + key*100 + (date+dayleft));
            }

            m_ptrMeaResult->CalcSetValue(calcResult, calcInfo->item, OB_M);
        }
        else
        {
            return MEA_FAIL;
        }
    }
    return MEA_SUCCESS;
}
#endif

int MeaCalcFun::EDCBFormula(const int gpLen, int gw, int *EDCB)
{
    unsigned char monthdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    unsigned char  mon, date, yearflow;
    int daypast, dayleft;
    int fast;
    unsigned int year, key;

    if (gw == INVALID_VAL)
        return MEA_FAIL;

    daypast = gw;
    time_t now;
    struct tm* ct;

    time(&now);
    ct = localtime(&now);

    year = (ct->tm_year + 1900) ;//% 100;
    mon = ct->tm_mon + 1;
    date = ct->tm_mday;

    if( daypast < gpLen )
    {
        if( !( year  % 4 ) )  monthdays[1] = 29;

        dayleft = gpLen - daypast;

        yearflow = 0;
        key = mon;
        fast = monthdays[ key - 1 ] - date;

        if( dayleft < fast )
        {
            *EDCB = year*10000 + key*100 + (date+dayleft);
        }
        else
        {
            dayleft -= fast;
            key++;

            if (key==13)
            {
                yearflow = 1;
                key = 1;
                if( !( (year + 1 ) % 4 ) )  monthdays[1] = 29;
                    else monthdays[1] = 28;
            }

            while( dayleft > monthdays[ key - 1 ] )
            {
                dayleft -= monthdays[ key - 1 ];
                if( ++key > 12 )
                {
                    yearflow = 1;
                    key = 1;
                    if( !( (year + 1 ) % 4 ) )  monthdays[1] = 29;
                    else monthdays[1] = 28;
                }
            }

            date = dayleft;
            year += yearflow;
            if (year > 9999) year = year - 10000;
            *EDCB = year*10000 + key*100 + date;
        }
    }
    else
    {
        return MEA_FAIL;
    }

    return MEA_SUCCESS;
}

//void CalculateEDCB(int daypast, unsigned char resultline, unsigned char year1, unsigned char mon1, unsigned char date1)
int MeaCalcFun::EDCBCalc(CalcInfoTmp *calcInfo, double data[], int item, int save, int *position, const int parPosi)
{
    unsigned int year,key;
    int dayleft, fast;
    unsigned char mon, date, yearflow;
    unsigned char monthdays[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };
    int daypast;
    double gw;
    double calcResult[CALC_RESULT_CLASSES];
    int i;
    int gpLen = HumanDOP;//孕期长度
#ifdef VET
    //hlx
/*
    if ((item >= OB_DOG_GSD) && (item <= OB_DOG_BD))
        gpLen = DogDOP;
    else if ((item >= OB_CAT_HD) && (item <= OB_CAT_BD))
        gpLen = CatDOP;
    else if ((item >= OB_SHEEP_CRL) && (item <= OB_SHEEP_CRL))
        gpLen = SheepDOP;
    else if ((item >= OB_SWINE_HLA) && (item <= OB_SWINE_SLA))
        gpLen = SwineDOP;
    else if ((item >= OB_BOVINE_CRL_H) && (item <= OB_BOVINE_BUD))
        gpLen = BovineDOP;
    else if ((item >= OB_EQUINE_GSD) && (item <= OB_EQUINE_EED))
        gpLen = EquineDOP;
    else
        gpLen = HumanDOP;
        */
    if ((item >= ANOB_DOG_GSD) && (item <= ANOB_DOG_BD))
        gpLen = DogDOP;
    else if ((item >= ANOB_CAT_HD) && (item <= ANOB_CAT_BD))
        gpLen = CatDOP;
    else if ((item >= ANOB_SHEEP_CRL) && (item <= ANOB_SHEEP_CRL))
        gpLen = SheepDOP;
    else if ((item >= ANOB_SWINE_HL) && (item <= ANOB_SWINE_SL))
        gpLen = SwineDOP;
    else if ((item >= ANOB_BOVINE_KCRL) && (item <= ANOB_BOVINE_BUD))
        gpLen = BovineDOP;
    else if ((item >= ANOB_EQUINE_GSD) && (item <= ANOB_EQUINE_EED))
        gpLen = EquineDOP;
    else
        gpLen = HumanDOP;
#endif
    for (i=0; i<CALC_RESULT_CLASSES; i++)
        calcResult[i] = INVALID_VAL;

    (*position)++;//在测量结束时自动把计算结果存放位置移后一个

    daypast = (int)data[MEA_SINGLE];
    if (daypast == INVALID_VAL)
        return MEA_FAIL;

    if (daypast == INVALID_VAL_GW)
    {
        data[MEA_SINGLE+1] = INVALID_VAL_GW;
        return MEA_FAIL;
    }

    time_t now;
    struct tm* ct;

    time(&now);
    ct = localtime(&now);

    year = (ct->tm_year + 1900);// % 100;
    mon = ct->tm_mon + 1;
    date = ct->tm_mday;

    if( daypast < gpLen )
    {
        if( !( year  % 4 ) )  monthdays[1] = 29;

        dayleft = gpLen - daypast;

        yearflow = 0;
        key = mon;
        fast = monthdays[ key - 1 ] - date;

        if( dayleft < fast )
        {
            data[MEA_SINGLE+1] = (double)(year*10000 + key*100 + (date+dayleft));
            calcResult[0] = (double)data[MEA_SINGLE+1];
        }
        else
        {
            dayleft -= fast;
            key++;

            if (key==13)
            {
                yearflow = 1;
                key = 1;
                if( !( (year + 1 ) % 4 ) )  monthdays[1] = 29;
                    else monthdays[1] = 28;
            }

            while( dayleft > monthdays[ key - 1 ] )
            {
                dayleft -= monthdays[ key - 1 ];
                if( ++key > 12 )
                {
                    yearflow = 1;
                    key = 1;
                    if( !( (year + 1 ) % 4 ) )  monthdays[1] = 29;
                    else monthdays[1] = 28;
                }
            }

            date = dayleft;

            year += yearflow;
            if (year > 9999) year = year - 10000;
            if(date <= 0)
            {
                key--;
                date = monthdays[key - 1];
            }
            data[MEA_SINGLE+1] = (double)(year*10000 + key*100 + date);
            calcResult[0] = data[MEA_SINGLE+1];
        }
    }
    else
    {
        data[MEA_SINGLE+1] = INVALID_VAL_GW;
        return MEA_FAIL;
    }

    if (save == SAVE)
    {
#ifdef VET
        m_ptrMeaResult->CalcGetMeanValue(&gw, calcInfo->item-1, ANOB_M);
#else
        m_ptrMeaResult->CalcGetMeanValue(&gw, calcInfo->item-1, OB_M);
#endif

        daypast = (int)gw;

        year = (ct->tm_year + 1900) ;//% 100;
        mon = ct->tm_mon + 1;
        date = ct->tm_mday;

        if( daypast < gpLen )
        {
            if( !( year  % 4 ) )  monthdays[1] = 29;

            dayleft = gpLen - daypast;

            yearflow = 0;
            key = mon;
            fast = monthdays[ key - 1 ] - date;

            if( dayleft < fast )
            {
                calcResult[1] = (double)(year*10000 + key*100 + (date+dayleft));
            }
            else
            {
                dayleft -= fast;
                key++;

                if (key==13)
                {
                    yearflow = 1;
                    key = 1;
                    if( !( (year + 1 ) % 4 ) )  monthdays[1] = 29;
                    else monthdays[1] = 28;
                }

                while( dayleft > monthdays[ key - 1 ] )
                {
                    dayleft -= monthdays[ key - 1 ];
                    if( ++key > 12 )
                    {
                        yearflow = 1;
                        key = 1;
                        if( !( (year + 1 ) % 4 ) )  monthdays[1] = 29;
                        else monthdays[1] = 28;
                    }
                }

                date = dayleft;

                year += yearflow;
                if (year > 9999) year = year - 10000;
                if(date <= 0)
                {
                    key--;
                    date = monthdays[key - 1];
                }
                calcResult[1] = (double)(year*10000 + key*100 + date);
            }
#ifdef VET
            m_ptrMeaResult->CalcSetValue(calcResult, calcInfo->item, ANOB_M);
#else
            m_ptrMeaResult->CalcSetValue(calcResult, calcInfo->item, OB_M);
#endif

        }
        else
        {
            data[MEA_SINGLE+1] = INVALID_VAL_GW;
            return MEA_FAIL;
        }
    }
    return MEA_SUCCESS;
}

/*
//此函数用于报告中
//本函数的参数和返回值原都应该是int型，为了适用回调的函数形式,均改成float型，在调用是需注意强制转换
float MeaCalcFun::EDCBCalc(float gw)
{
    return (double)0;
}
*/
int MeaCalcFun::EFWGetData(const int item, const int state, const int method, double data[])
{
    int sign;
    double ac[MEA_MULTI], fl[MEA_MULTI], hc[MEA_MULTI], bpd[MEA_MULTI], tad[MEA_MULTI], apad[MEA_MULTI];
    int i;

    m_ptrMeaResult = MeaResult::GetInstance();
    for (i=0; i<MEA_MULTI; i++)
    {
        ac[i] = INVALID_VAL;
        fl[i] = INVALID_VAL;
        hc[i] = INVALID_VAL;
        bpd[i] = INVALID_VAL;
        tad[i] = INVALID_VAL;
        apad[i] = INVALID_VAL;
    }

    if (state == IN_REPORT_MEAN)
    {
        switch(method)
        {
            case EFW_HADLOCK1:
                sign = m_ptrMeaResult->GetValue(OB_AC, ac, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_FL, fl, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                break;

            case EFW_HADLOCK2:
                sign = m_ptrMeaResult->GetValue(OB_AC, ac, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_FL, fl, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_BPD, bpd, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                break;

            case EFW_HADLOCK3:
                sign = m_ptrMeaResult->GetValue(OB_AC, ac, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_FL, fl, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_HC, hc, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                break;

            case EFW_HADLOCK4:
                sign = m_ptrMeaResult->GetValue(OB_AC, ac, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_FL, fl, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_BPD, bpd, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_HC, hc, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                break;

            case EFW_SHEPARD:
                sign = m_ptrMeaResult->GetValue(OB_AC, ac, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_BPD, bpd, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                break;

            case EFW_HANSMAN:
                sign = m_ptrMeaResult->GetValue(OB_TAD, tad, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_BPD, bpd, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                break;

            case EFW_TOKYO:
                sign = m_ptrMeaResult->GetValue(OB_TAD, tad, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_APAD, apad, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_FL, fl, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                sign = m_ptrMeaResult->GetValue(OB_BPD, bpd, NULL, state);
                if (sign != MEA_SUCCESS) return sign;
                break;

            default:
                return MEA_ERROR;
        }
    }
    else if (state == IN_MEASURE)
    {
        switch(method)
        {
            case EFW_HADLOCK1:
                if (item != OB_AC)
                {
                    sign = m_ptrMeaResult->GetValue(OB_AC, ac, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_FL)
                {
                    sign = m_ptrMeaResult->GetValue(OB_FL, fl, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                break;

            case EFW_HADLOCK2:
                if (item != OB_AC)
                {
                    sign = m_ptrMeaResult->GetValue(OB_AC, ac, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_FL)
                {
                    sign = m_ptrMeaResult->GetValue(OB_FL, fl, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_BPD)
                {
                    sign = m_ptrMeaResult->GetValue(OB_BPD, bpd, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                break;

            case EFW_HADLOCK3:
                if (item != OB_AC)
                {
                    sign = m_ptrMeaResult->GetValue(OB_AC, ac, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_FL)
                {
                    sign = m_ptrMeaResult->GetValue(OB_FL, fl, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_HC)
                {
                    sign = m_ptrMeaResult->GetValue(OB_HC, hc, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                break;

            case EFW_HADLOCK4:
                if (item != OB_AC)
                {
                    sign = m_ptrMeaResult->GetValue(OB_AC, ac, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_FL)
                {
                    sign = m_ptrMeaResult->GetValue(OB_FL, fl, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_BPD)
                {
                    sign = m_ptrMeaResult->GetValue(OB_BPD, bpd, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_HC)
                {
                    sign = m_ptrMeaResult->GetValue(OB_HC, hc, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                break;

            case EFW_SHEPARD:
                if (item != OB_AC)
                {
                    sign = m_ptrMeaResult->GetValue(OB_AC, ac, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_BPD)
                {
                    sign = m_ptrMeaResult->GetValue(OB_BPD, bpd, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                break;

            case EFW_HANSMAN:
                if (item != OB_TAD)
                {
                    sign = m_ptrMeaResult->GetValue(OB_TAD, tad, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_BPD)
                {
                    sign = m_ptrMeaResult->GetValue(OB_BPD, bpd, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                break;

            case EFW_TOKYO:
                if (item != OB_TAD)
                {
                    sign = m_ptrMeaResult->GetValue(OB_TAD, tad, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_APAD)
                {
                    sign = m_ptrMeaResult->GetValue(OB_APAD, apad, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_FL)
                {
                    sign = m_ptrMeaResult->GetValue(OB_FL, fl, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                if (item != OB_BPD)
                {
                    sign = m_ptrMeaResult->GetValue(OB_BPD, bpd, NULL, state);
                    if (sign != MEA_SUCCESS) return sign;
                }
                break;

            default:
                return MEA_ERROR;
        }
    }

    data[0] = ac[0];
    data[1] = fl[0];
    data[2] = hc[0];
    data[3] = bpd[0];
    data[4] = tad[0];
    data[5] = apad[0];
    return MEA_SUCCESS;
}

#if 0
//float MeaCalcFun::EFWCalc(float curr_value)
int MeaCalcFun::EFWCalc(CalcInfoTmp *calcInfo, float data[], int item, int save, int position)
{
    int method;
    float fl = 0, ac = 0, hc = 0, bpd = 0, tad = 0, apad = 0;
    float fl1 = 0, ac1 = 0, hc1 = 0, bpd1 = 0, tad1 = 0, apad1 = 0;
    float efw, efw1;
    float dataOther[6];
    int sign;
    float calcResult[CALC_RESULT_CLASSES];
    int i;

    for (i=0; i<CALC_RESULT_CLASSES; i++)
        calcResult[i] = INVALID_VAL;

    m_ptrMeaResult = MeaResult::GetInstance();
    //  method = GetEfwMethod();
    method = EFW_HADLOCK1;
//  method = 0;

    sign = EFWGetData(item, IN_MEASURE, method, dataOther);
    if (sign != MEA_SUCCESS) return sign;

    ac = dataOther[0];
    fl = dataOther[1];
    hc = dataOther[2];
    bpd = dataOther[3];
    tad = dataOther[4];
    apad = dataOther[5];

    if (save == NOT_SAVE)//测量中
    {
        switch(item)
        {
            case OB_FL:
                fl = data[0];
                break;

            case OB_AC:
                ac = data[0];
                break;

            case OB_HC:
                hc = data[0];
                break;

            case OB_BPD:
                bpd = data[0];
                break;

            case OB_TAD:
                tad = data[0];
                break;

            case OB_APAD:
                apad = data[0];
                break;

            default:
                return MEA_ERROR;
        }
    }
    else
    {
        sign = EFWGetData(item, IN_REPORT_MEAN, method, dataOther);
        if (sign != MEA_SUCCESS) return sign;

        ac1 = dataOther[0];
        fl1 = dataOther[1];
        hc1 = dataOther[2];
        bpd1 = dataOther[3];
        tad1 = dataOther[4];
        apad1 = dataOther[5];
    }

    int day = 0, week = 0;
    if(method==EFW_HADLOCK1)
    {
        if ( ac==INVALID_VAL || fl==INVALID_VAL)
            return MEA_FAIL;

        //  day = GetMeanGW();
            day = 210;
        if ((day%7) > 0)
            week = day/7 + 1;
        else
            week = day/7;

        if((week>=20) && (week<=42))
        {
            efw = pow(10 , (1.304+0.05281*ac*0.1+0.1938*fl*0.1-0.004*ac*fl*0.01));
            efw = efw*0.001;

            if (save == SAVE)
            {
                efw1 = pow(10 , (1.304+0.05281*ac1*0.1+0.1938*fl1*0.1-0.004*ac1*fl1*0.01));
                efw1 = efw1*0.001;
            }
        }
        else
            return MEA_FAIL;
    }
    else if(method==EFW_HADLOCK2)
    {
        if (bpd==INVALID_VAL || ac==INVALID_VAL || fl==INVALID_VAL)
            return MEA_FAIL;

        //  day = GetMeanGW();
            day = 210;
        if ((day%7) > 0)
            week = day/7 + 1;
        else
            week = day/7;

        if((week>=20) && (week<=42))
        {
            efw = pow(10 ,(1.335-0.0034*ac*fl*0.01+0.0316*bpd*0.1+0.0457*ac*0.1+0.1623*fl*0.1));
            efw = efw*0.001;

            if(save == SAVE)
            {
                efw1 = pow(10 ,(1.335-0.0034*ac1*fl1*0.01+0.0316*bpd1*0.1+0.0457*ac1*0.1+0.1623*fl1*0.1));
                efw1 = efw1*0.001;
            }
        }
        else
            return MEA_FAIL;
    }
    else if(method==EFW_HADLOCK3)
    {
        if (hc==INVALID_VAL || ac==INVALID_VAL || fl==INVALID_VAL)
            return MEA_FAIL;

        //  day = GetMeanGW();
        if ((day%7) > 0)
            week = day/7 + 1;
        else
            week = day/7;

        if((week>=20) && (week<=42))
        {
            efw = pow(10,(1.326-0.00326*ac*fl*0.01+0.0107*hc*0.1+0.0438*ac*0.1+0.158*fl*0.1));
            efw = efw*0.001;

            if(save == SAVE)
            {
                efw1 = pow(10,(1.326-0.00326*ac1*fl1*0.01+0.0107*hc1*0.1+0.0438*ac1*0.1+0.158*fl1*0.1));
                efw1 = efw1*0.001;
            }
        }
        else
            return MEA_FAIL;
    }
    else if(method==EFW_HADLOCK4)
    {
        if (hc==INVALID_VAL || bpd==INVALID_VAL || ac==INVALID_VAL || fl==INVALID_VAL)
            return MEA_FAIL;

        //  day = GetMeanGW();
        if ((day%7) > 0)
            week = day/7 + 1;
        else
            week = day/7;

        if((week>=20) && (week<=42))
        {
            efw = pow(10,(1.3596-0.00386*ac*fl*0.01+0.0064*hc*0.1+0.00061*bpd*ac*0.01+0.0424*ac*0.1+0.174*fl*0.1));
            efw = efw*0.001;

            if(save == SAVE)
            {
                efw1 = pow(10,(1.3596-0.00386*ac1*fl1*0.01+0.0064*hc1*0.1+0.00061*bpd1*ac1*0.01+0.0424*ac1*0.1+0.174*fl1*0.1));
                efw1 = efw1*0.001;
            }
        }
        else
            return MEA_FAIL;
    }
    else if(method==EFW_SHEPARD)
    {
        if((bpd>=31) && (bpd<=100) && (ac>=155) && (ac<=400))
        {
            efw = pow(10,(-1.7492+0.166*bpd*0.1+0.046*ac*0.1-2.646*(ac*bpd*0.01)/1000));

            if(save == SAVE)
            {
                efw1 = pow(10,(-1.7492+0.166*bpd1*0.1+0.046*ac1*0.1-2.646*(ac1*bpd1*0.01)/1000));
            }
        }
        else
            return MEA_FAIL;
    }
    else if(method==EFW_HANSMAN)
    {
        if (bpd==INVALID_VAL || tad==INVALID_VAL)
            return MEA_FAIL;

        //  day = GetMeanGW();
        if ((day%7) > 0)
            week = day/7 + 1;
        else
            week = day/7;

        if((week>=30) && (week<=44) && (tad>=45) && (tad<=150) && (bpd>=66) && (bpd<=110))
        {
            efw=-0.001665958*tad*tad*tad+0.4133629*tad*tad-0.5580294*tad
                -0.01231535*bpd*bpd*bpd+3.702*bpd*bpd-330.1811*bpd
                -0.4937199*week*week*week+55.958061*week*week-2034.3901*week+32768.19+0.5;
            efw=efw*0.001;

            if(save == SAVE)
            {
                //  day = GetMeanGW();
                if ((day%7) > 0)
                    week = day/7 + 1;
                else
                    week = day/7;

                efw1=-0.001665958*tad1*tad1*tad1+0.4133629*tad1*tad1-0.5580294*tad1
                    -0.01231535*bpd1*bpd1*bpd1+3.702*bpd1*bpd1-330.1811*bpd1
                    -0.4937199*week*week*week+55.958061*week*week-2034.3901*week+32768.19+0.5;
                efw1=efw1*0.001;
            }
        }
        else
            return MEA_FAIL;

    }
    else if(method==EFW_TOKYO)
    {
        if (bpd==INVALID_VAL || tad==INVALID_VAL || fl==INVALID_VAL)
        {
            efw = 1.07*bpd*bpd*bpd*0.001 + 3.42*apad*tad*fl*0.001+0.5;
            efw = efw*0.001;

            if(save == SAVE)
            {
                efw1 = 1.07*bpd1*bpd1*bpd1*0.001 + 3.42*apad1*tad1*fl1*0.001+0.5;
                efw1 = efw1*0.001;
            }
        }
        else
            return MEA_FAIL;
    }

    data[3] = efw;
    calcResult[0] = efw;
    calcResult[1] = efw1;
    if (save == SAVE)
    {
        m_ptrMeaResult->CalcSetValue(calcResult, calcInfo->item, OB_M);
    }

    //printf("\n(*)(*)(*)EFW: efw= %f\n", efw);

    return MEA_SUCCESS;
}
#endif

int MeaCalcFun::EFWCalc(CalcInfoTmp *calcInfo, double data[], int item, int save, int *position, const int parPosi)
{
    double fl = 0, ac = 0, hc = 0, bpd = 0, tad = 0, apad = 0;
    double fl1 = 0, ac1 = 0, hc1 = 0, bpd1 = 0, tad1 = 0, apad1 = 0;
    double efw = INVALID_VAL, efw1 = INVALID_VAL;
    double dataOther[6];
    double meanData[6];
    int sign;
    double calcResult[CALC_RESULT_CLASSES];
    int i;

    for (i=0; i<CALC_RESULT_CLASSES; i++)
        calcResult[i] = INVALID_VAL;

    (*position)++;//在测量结束时自动把计算结果存放位置移后一个

    m_ptrMeaResult = MeaResult::GetInstance();
    const int method = GetCurEfwMethod();//获取 EFW的方法
//  printf("EFW method= %d\n", method);
    if (method + OB_EFW != calcInfo->item)//如果当前方法不是本EFW，则直接返回
        return MEA_FAIL;

    sign = EFWGetData(item, IN_MEASURE, method, dataOther);
    if (sign != MEA_SUCCESS) return sign;

    ac = dataOther[0];
    fl = dataOther[1];
    hc = dataOther[2];
    bpd = dataOther[3];
    tad = dataOther[4];
    apad = dataOther[5];

    switch(item)
    {
        case OB_FL:
            fl = data[parPosi];
            break;

        case OB_AC:
            ac = data[parPosi];
            break;

        case OB_HC:
            hc = data[parPosi];
            break;

        case OB_BPD:
            bpd = data[parPosi];
            break;

        case OB_TAD:
            tad = data[parPosi];
            break;

        case OB_APAD:
            apad = data[parPosi];
            break;

        default:
            return MEA_ERROR;
    }

    if (save == SAVE)
    {
        sign = EFWGetData(item, IN_REPORT_MEAN, method, meanData);
        if (sign != MEA_SUCCESS) return sign;

        ac1 = meanData[0];
        fl1 = meanData[1];
        hc1 = meanData[2];
        bpd1 = meanData[3];
        tad1 = meanData[4];
        apad1 = meanData[5];
    }

    int day = 0, week = 0;
    double value[2];
    sign = m_ptrMeaResult->CalcGetAgwValue(value, g_menuCalc.GetCurrentFetal());
    if (sign != MEA_SUCCESS)    return sign;
    day = value[0];
    if(method == EFW_HADLOCK1)
    {
        if ( ac==INVALID_VAL || fl==INVALID_VAL)
            return MEA_FAIL;

        if ((day%7) > 0)
            week = day/7 + 1;
        else
            week = day/7;

        if((week>=20) && (week<=42))
        {
            efw = pow(10 , (1.304+0.05281*ac+0.1938*fl-0.004*ac*fl));
            efw = efw*0.001;
        }
        else
            return MEA_FAIL;

        if (save == SAVE)
        {
            if((week>=20) && (week<=42))
            {
                efw1 = pow(10 , (1.304+0.05281*ac1+0.1938*fl1-0.004*ac1*fl1));
                efw1 = efw1*0.001;
            }
            else
                efw1 = INVALID_VAL;
        }
    }
    else if(method == EFW_HADLOCK2)
    {
        if (bpd==INVALID_VAL || ac==INVALID_VAL || fl==INVALID_VAL)
            return MEA_FAIL;

        if ((day%7) > 0)
            week = day/7 + 1;
        else
            week = day/7;

        if((week>=20) && (week<=42))
        {
            efw = pow(10 ,(1.335-0.0034*ac*fl+0.0316*bpd+0.0457*ac+0.1623*fl));
            efw = efw*0.001;
        }
        else
            return MEA_FAIL;

        if (save == SAVE)
        {
            if((week>=20) && (week<=42))
            {
                efw1 = pow(10 ,(1.335-0.0034*ac1*fl1+0.0316*bpd1+0.0457*ac1+0.1623*fl1));
                efw1 = efw1*0.001;
            }
            else
                efw1 = INVALID_VAL;
        }
    }
    else if(method == EFW_HADLOCK3)
    {
        if (hc==INVALID_VAL || ac==INVALID_VAL || fl==INVALID_VAL)
            return MEA_FAIL;

        if ((day%7) > 0)
            week = day/7 + 1;
        else
            week = day/7;

        if((week>=20) && (week<=42))
        {
            efw = pow(10,(1.326-0.00326*ac*fl+0.0107*hc+0.0438*ac+0.158*fl));
            efw = efw*0.001;
        }
        else
            return MEA_FAIL;

        if (save == SAVE)
        {
            if((week>=20) && (week<=42))
            {
                efw1 = pow(10,(1.326-0.00326*ac1*fl1+0.0107*hc1+0.0438*ac1+0.158*fl1));
                efw1 = efw1*0.001;
            }
            else
                efw1 = INVALID_VAL;
        }
    }
    else if(method == EFW_HADLOCK4)
    {
        if (hc==INVALID_VAL || bpd==INVALID_VAL || ac==INVALID_VAL || fl==INVALID_VAL)
            return MEA_FAIL;

        if ((day%7) > 0)
            week = day/7 + 1;
        else
            week = day/7;

        if((week>=20) && (week<=42))
        {
            efw = pow(10,(1.3596-0.00386*ac*fl+0.0064*hc+0.00061*bpd*ac+0.0424*ac+0.174*fl));
            efw = efw*0.001;
        }
        else
            return MEA_FAIL;

        if (save == SAVE)
        {
            if((week>=20) && (week<=42))
            {
                efw1 = pow(10,(1.3596-0.00386*ac1*fl1+0.0064*hc1+0.00061*bpd1*ac1+0.0424*ac1+0.174*fl1));
                efw1 = efw1*0.001;
            }
            else
                efw1 = INVALID_VAL;
        }
    }
    else if(method == EFW_SHEPARD)
    {
        if((bpd>=3.1) && (bpd<=10.0) && (ac>=15.5) && (ac<=40.0))
        {
            efw = pow(10,(-1.7492+0.166*bpd+0.046*ac-2.646*(ac*bpd)/1000));
        }
        else
            return MEA_FAIL;

        if (save == SAVE)
        {
            if((bpd1>=3.1) && (bpd1<=10.0) && (ac1>=15.5) && (ac1<=40.0))
            {
                efw = pow(10,(-1.7492+0.166*bpd1+0.046*ac1-2.646*(ac1*bpd1)/1000));
            }
            else
                efw1 = INVALID_VAL;
        }
    }
    else if(method == EFW_HANSMAN)
    {
        if (bpd==INVALID_VAL || tad==INVALID_VAL)
            return MEA_FAIL;

        if ((day%7) > 0)
            week = day/7 + 1;
        else
            week = day/7;

        if((week>=30) && (week<=44) && (tad>=4.5) && (tad<=15.0) && (bpd>=6.6) && (bpd<=11.0))
        {
            efw=-1.665958*tad*tad*tad+41.33629*tad*tad-5.580294*tad
                -12.31535*bpd*bpd*bpd+370.2*bpd*bpd-3301.811*bpd
                -0.4937199*week*week*week+55.958061*week*week-2034.3901*week+32768.19+0.5;
            efw=efw*0.001;
        }
        else
            return MEA_FAIL;

        if (save == SAVE)
        {
            if((week>=30) && (week<=44) && (tad1>=4.5) && (tad1<=15.0) && (bpd1>=6.6) && (bpd1<=11.0))
            {
                efw1=-1.665958*tad1*tad1*tad1+41.33629*tad1*tad1-5.580294*tad1
                    -12.31535*bpd1*bpd1*bpd1+370.2*bpd1*bpd1-3301.811*bpd1
                    -0.4937199*week*week*week+55.958061*week*week-2034.3901*week+32768.19+0.5;
                efw1=efw1*0.001;
            }
            else
                efw1 = INVALID_VAL;
        }
    }
    else if(method == EFW_TOKYO)
    {
        if (bpd==INVALID_VAL || tad==INVALID_VAL || apad== INVALID_VAL || fl==INVALID_VAL)
            return MEA_FAIL;
        else
        {
            efw = 1.07*bpd*bpd*bpd + 3.42*apad*tad*fl+0.5;
            efw = efw*0.001;
        }

        if (save == SAVE)
        {
            if (bpd1!=INVALID_VAL && tad1!=INVALID_VAL && apad!= INVALID_VAL && fl1!=INVALID_VAL)
            {
                efw1 = 1.07*bpd1*bpd1*bpd1 + 3.42*apad1*tad1*fl1+0.5;
                efw1 = efw1*0.001;
            }
            else
                efw1 = INVALID_VAL;
        }
    }

    data[3] = efw;
    calcResult[0] = efw;
    calcResult[1] = efw1;
    if (save == SAVE)
    {
        m_ptrMeaResult->CalcSetValue(calcResult, calcInfo->item, OB_M);
    }

    return MEA_SUCCESS;
}

void MeaCalcFun::InitCustomTable()
{
    FILE *fp;
    int i;
    char buf[10];

    if((fp = fopen(OB_CUSTOM_PATH, "r")) == NULL)
    {
        PRINTF("fopen fail (CustomOB.txt), the error is %s\n", strerror(errno));
        return;
    }
    if(fseek(fp, 0, SEEK_SET) == -1)
    {
        PRINTF("fseek fail (CustomOB.txt), the error is %s\n", strerror(errno));
        fclose(fp);
        return;
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        cer_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        hl_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        bpd_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        fl_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        crl_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        gs_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        ac_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        hc_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        tad_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        apad_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        thd_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        ofd_custom[i] = atoi(buf);
    }

    for (i=0; i<272; i++)
    {
        fgets(buf, 10, fp);
        fta_custom[i] = atoi(buf);
    }

    fclose(fp);
}

void MeaCalcFun::SetTableMaxMin(int table[])
{
    int i, j;
    float fmin, fmax;

    table[270] = table[271] = 0;

    for(i=0; i<270; i++)
    {
        if (table[i]==0) continue;
        else
        {
            fmin = fmax = table[i];
            for(j=i+1; j<270; j++)
            {
                if (table[j]==0) continue;
                else
                {
                    if (table[j] < fmin)
                        fmin = table[j];
                    if (table[j] > fmax)
                        fmax = table[j];
                }
            }
            table[270] = fmin;
            table[271] = fmax;
        }
        break;
    }

}

bool MeaCalcFun::SaveCustomTable()
{
//  printf("%s\n", __FUNCTION__);
    SetTableMaxMin(cer_custom);
    SetTableMaxMin(hl_custom);
    SetTableMaxMin(bpd_custom);
    SetTableMaxMin(fl_custom);
    SetTableMaxMin(crl_custom);
    SetTableMaxMin(gs_custom);
    SetTableMaxMin(ac_custom);
    SetTableMaxMin(hc_custom);
    SetTableMaxMin(tad_custom);
    SetTableMaxMin(apad_custom);
    SetTableMaxMin(thd_custom);
    SetTableMaxMin(ofd_custom);
    SetTableMaxMin(fta_custom);

    FILE *fp;
    int i;
    char buf[10];

    if ((fp = fopen(OB_CUSTOM_PATH, "w+")) == NULL )
    {
        PRINTF("fopen fail (CustomOB.txt), the error is %s\n", strerror(errno));
        return false;
    }
    if (fseek(fp, 0, SEEK_SET) == -1)
    {
        PRINTF("fseek fail (CustomOB.txt), the error is %s\n", strerror(errno));
        fclose(fp);
        return false;
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", cer_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", hl_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", bpd_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", fl_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", crl_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", gs_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", ac_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", hc_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", tad_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", apad_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", thd_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", ofd_custom[i]);
        fputs(buf, fp);
    }
    for (i=0; i<272; i++)
    {
        sprintf(buf, "%d\n", fta_custom[i]);
        fputs(buf, fp);
    }

    fclose(fp);

    return true;
}